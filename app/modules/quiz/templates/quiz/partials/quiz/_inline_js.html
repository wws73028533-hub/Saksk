const mode = '{{ mode }}';
const source = '{{ source or "" }}';
const LOGGED_IN = {{ 'true' if logged_in else 'false' }};
const USER_KEY = "{{ user_id if logged_in else 'guest' }}"; // 用 user_id 作为进度隔离键

// 记录“上次练习入口”，用于侧边栏/移动端的“继续上次”
(function rememberLastPracticeUrl(){
    try {
        const params = new URLSearchParams(window.location.search);
        const currentMode = params.get('mode') || mode || 'quiz';
        if (currentMode === 'exam') return;
        const url = window.location.pathname + window.location.search;
        localStorage.setItem('sak:lastPracticeUrl', url);
        localStorage.setItem('sak:lastPracticeAt', String(Date.now()));
    } catch (e) {}
})();


// 优化后的进度键生成函数 - 标准化参数顺序,避免重复进度
// 重要：必须与后端 quiz.py 中的 key 生成逻辑保持一致！
// 个人题库：/quiz?bank_id=<id>
const BANK_ID = (() => {
    try {
        const params = new URLSearchParams(window.location.search);
        const v = (params.get('bank_id') || '').trim();
        const n = v ? parseInt(v, 10) : NaN;
        return Number.isFinite(n) && n > 0 ? n : null;
    } catch (e) {
        return null;
    }
})();
const IS_USER_BANK = !!BANK_ID;
function getUserBankApiPrefix(){
    return IS_USER_BANK ? `/user/banks/api/${BANK_ID}` : '';
}

function progressKey(){
    const params = new URLSearchParams(window.location.search);
    let subject = params.get('subject') || 'all';
    if (IS_USER_BANK) subject = `bank_${BANK_ID}`;
    const type = params.get('type') || 'all';
    const currentMode = params.get('mode') || mode || 'quiz';
    const tag = (params.get('tag') || '').trim();
    
    // 考试模式使用exam_id作为唯一标识
    if (currentMode === 'exam') {
        const examId = params.get('exam_id');
        if (examId) {
            return `quiz_progress_${USER_KEY}_exam_${examId}`;
        }
    }
    
    // 计算 data_scope（与后端 quiz.py 保持一致）
    // 后端逻辑：data_scope = target if target in ('favorites', 'mistakes') else 'all'
    // target = source if source in ('favorites', 'mistakes') else mode
    const sourceParam = params.get('source') || '';
    let dataScope = 'all';
    if (sourceParam === 'favorites' || sourceParam === 'mistakes') {
        dataScope = sourceParam;
    }
    
    // 其他模式使用标准化的科目+题型+模式+data_scope+打乱设置
    const shuffleQ = params.get('shuffle_questions') === '1' ? '1' : '0';
    const shuffleO = params.get('shuffle_options') === '1' ? '1' : '0';
    const tagPart = (tag && tag.toLowerCase() !== 'all') ? `_tag${tag}` : '';
    return `quiz_progress_${USER_KEY}_${currentMode}_${subject}_${type}_${dataScope}${tagPart}_q${shuffleQ}_o${shuffleO}`;
}
let questions = document.querySelectorAll('.question-box');
const EXAM_ID = (function(){ const el = document.getElementById('mainCard'); return el ? (el.dataset.examId || '') : ''; })();
const EXAM_SUBMITTED = {{ 'true' if submitted else 'false' }};
const USER_ANSWERS = {{ user_answers_json|safe if user_answers_json else '{}' }};
let listItems = document.querySelectorAll('.q-item');

function isSubjectiveType(type){
    return type === '问答题' || type === '简答题' || type === '计算题';
}

function isAutoCheckType(type, qEl = null){
    // 对齐小程序：单选题/判断题点选即判；多选题/填空/主观题需要“提交答案”
    // 注意：部分“选择题”可能存在多答案（例如答案为 'AB'），此时应视为“需要提交”的题型
    if (type === '判断题') return true;
    if (type !== '选择题') return false;
    const ans = qEl ? (qEl.getAttribute('data-answer') || '') : '';
    return String(ans || '').trim().length <= 1;
}

function isJudgableType(type){
    return type === '选择题' || type === '判断题' || type === '多选题' || type === '填空题';
}

function isPracticeMode(){
    // 兼容 favorites/mistakes 等“范围模式”：行为与刷题一致
    return mode !== 'exam' && mode !== 'memo';
}

function getQuestionIndexFromEl(qEl){
    const idx = parseInt(qEl?.getAttribute('data-index') || '');
    return Number.isFinite(idx) ? idx : null;
}

function isQuestionAlreadyChecked(qEl){
    if (!qEl) return false;
    if (qEl.classList.contains('checked-mode')) return true;
    const idx = getQuestionIndexFromEl(qEl);
    if (idx === null) return false;
    const li = document.getElementById(`list-item-${idx}`);
    return !!(li && (li.classList.contains('done-correct') || li.classList.contains('done-wrong')));
}

function getBottomSubmitElements(){
    const btnCheck = document.getElementById('btn-check');
    const wrapper = btnCheck ? btnCheck.closest('.submit-btn-wrapper') : null;
    return { btnCheck, wrapper };
}

function shouldShowBottomSubmit(type, qEl){
    if (!isPracticeMode()) return false;
    if (!qEl) return false;
    if (isSubjectiveType(type)) return false; // 主观题使用右侧输入区内提交按钮
    // 多选题：按需求放到选项下面（不占用底部栏）
    if (type === '多选题') return false;
    if (type === '填空题') return true;
    if (type === '选择题' && !isAutoCheckType(type, qEl)) return true; // 多答案“选择题”
    return false;
}

function syncFixedBarsMetrics(){
    if (!document.body.classList.contains('quiz-layout-card')) return;
    const root = document.documentElement;
    const header = document.querySelector('.header');
    const footer = document.querySelector('.footer');
    const bottomActions = document.querySelector('.footer .bottom-actions');

    try {
        if (header) {
            const pt = parseFloat(getComputedStyle(header).paddingTop) || 0;
            const safeTop = Math.max(0, pt - 10); // parity CSS: padding-top = env(safe-area-inset-top) + 10px
            const base = Math.max(0, header.getBoundingClientRect().height - safeTop);
            root.style.setProperty('--quiz-topbar-h', `${base}px`);
        }
        let safeBottom = 0;
        if (bottomActions) {
            const pb = parseFloat(getComputedStyle(bottomActions).paddingBottom) || 0;
            safeBottom = Math.max(0, pb - 14); // parity CSS: padding-bottom = 14px + env(safe-area-inset-bottom)
        }
        if (footer) {
            const base = Math.max(0, footer.getBoundingClientRect().height - safeBottom);
            root.style.setProperty('--quiz-bottombar-h', `${base}px`);
        }
    } catch(e) {}
}

function updateBottomSubmitState(qEl){
    const { btnCheck, wrapper } = getBottomSubmitElements();
    if (!btnCheck || !wrapper) return;

    if (!isPracticeMode()) {
        wrapper.style.display = 'none';
        btnCheck.disabled = true;
        syncFixedBarsMetrics();
        return;
    }

    if (!qEl) {
        wrapper.style.display = 'none';
        btnCheck.disabled = true;
        syncFixedBarsMetrics();
        return;
    }

    const type = (qEl.getAttribute('data-type') || '').toString();
    const show = !isQuestionAlreadyChecked(qEl) && shouldShowBottomSubmit(type, qEl);

    wrapper.style.display = show ? 'block' : 'none';
    btnCheck.disabled = show ? (!hasAnswered(qEl, type)) : true;
    syncFixedBarsMetrics();
}

function updateSubjectiveSubmitState(qEl){
    if (!qEl) return;
    const type = (qEl.getAttribute('data-type') || '').toString();
    if (!isSubjectiveType(type)) return;
    const btn = qEl.querySelector('.subjective-submit-btn');
    if (!btn) return;
    const disabled = !hasAnswered(qEl, type);
    // 为避免“按钮失效”问题，这里只做视觉禁用（仍允许点击，由 checkAnswer 做兜底校验）
    btn.disabled = false;
    btn.classList.toggle('disabled', disabled);
}

function updateMultiSubmitState(qEl){
    if (!qEl) return;
    const type = (qEl.getAttribute('data-type') || '').toString();
    const wrapper = qEl.querySelector('.multi-submit-wrapper');
    const btn = qEl.querySelector('.multi-submit-btn');
    if (!wrapper || !btn) return;

    if (!isPracticeMode() || type !== '多选题') {
        wrapper.style.display = 'none';
        btn.disabled = true;
        return;
    }

    const alreadyChecked = isQuestionAlreadyChecked(qEl);
    wrapper.style.display = alreadyChecked ? 'none' : 'block';
    btn.disabled = alreadyChecked ? true : !hasAnswered(qEl, type);
}

// ===== 题目转发（发送到站内聊天） =====
const forwardBtn = document.getElementById('forward-question-btn');
if (forwardBtn) {
    forwardBtn.addEventListener('click', ()=>{
        if (!LOGGED_IN) { showToast('请先登录后再转发'); return; }
        openForwardModal();
    });
}

function closeForwardModal(e){
    if (e) {
        // 点击遮罩关闭
        if (e.target && e.target.id !== 'forwardOverlay') return;
    }
    const ov = document.getElementById('forwardOverlay');
    if (ov) ov.style.display = 'none';
    const list = document.getElementById('forwardUserList');
    if (list) list.innerHTML = '';
}

function openForwardModal(){
    const ov = document.getElementById('forwardOverlay');
    if (!ov) return;
    ov.style.display = 'flex';

    // 预览当前题目
    try {
        const q = questions[currentIndex];
        const qid = q ? (q.getAttribute('data-id') || '') : '';
        const qtype = q ? (q.getAttribute('data-type') || '') : '';
        const meta = document.getElementById('forwardQMeta');
        const content = document.getElementById('forwardQContent');
        if (meta) meta.textContent = `ID: ${qid} · 题型: ${qtype} · 第 ${currentIndex+1} 题 / ${totalQuestions}`;
        if (content) {
            const el = q ? q.querySelector('.q-content') : null;
            content.textContent = el ? (el.innerText || '').trim() : '';
        }
    } catch(err) {}

    // 默认拉一次用户列表
    fetchForwardUsers();

    // 聚焦搜索框
    try { const inp = document.getElementById('forwardUserSearch'); if (inp) inp.focus(); } catch(e) {}
}

function onForwardUserSearchKey(e){
    if (e.key === 'Enter') {
        e.preventDefault();
        fetchForwardUsers();
    }
}

function escapeHtml(s){
    const div = document.createElement('div');
    div.textContent = s || '';
    return div.innerHTML;
}

async function fetchForwardUsers(){
    const inp = document.getElementById('forwardUserSearch');
    const kw = (inp && inp.value) ? inp.value.trim() : '';
    // 只获取已有会话的用户列表
    const res = await fetch(`/api/chat/conversation_users?q=${encodeURIComponent(kw)}`);
    const js = await res.json();
    if (!res.ok || js.status !== 'success') {
        showToast(js.message || '获取用户列表失败');
        return;
    }
    renderForwardUserList(js.data || []);
}

function renderForwardUserList(users){
    const list = document.getElementById('forwardUserList');
    if (!list) return;
    if (!users.length) {
        list.innerHTML = `<div style="padding:10px 6px; color:var(--text-sub);">暂无聊天会话，请先在聊天中与用户建立会话</div>`;
        return;
    }

    list.innerHTML = users.slice(0, 50).map(u=>{
        // 优先显示备注，没有备注则显示用户名
        const displayName = (u.remark && u.remark.trim()) ? u.remark.trim() : (u.username || '用户');
        const avatar = u.avatar || '';
        const initial = (displayName || 'U').slice(0,1).toUpperCase();
        const avHtml = avatar
          ? (()=>{
                const safeUrl = String(avatar||'')
                    .replace(/'/g, '%27')
                    .replace(/\)/g, '%29');
                return '<div style="width:38px;height:38px;border-radius:999px;background-image:url(&quot;' + safeUrl + '&quot;);background-size:cover;background-position:center;"></div>';
            })()
          : `<div style="width:38px;height:38px;border-radius:999px;background:var(--primary);color:#fff;display:flex;align-items:center;justify-content:center;font-weight:700;">${escapeHtml(initial)}</div>`;

        // 如果有备注，显示备注和用户名；否则只显示用户名
        const nameHtml = u.remark && u.remark.trim()
            ? `<div style="font-weight:700;">${escapeHtml(displayName)}</div><div style="font-size:11px; color:var(--text-sub);">${escapeHtml(u.username || '')}</div>`
            : `<div style="font-weight:700;">${escapeHtml(displayName)}</div>`;

        return `
          <div style="display:flex; align-items:center; gap:10px; padding:10px 10px; border-radius:14px; border:1px solid var(--border-color); cursor:pointer;" onclick="forwardToUser(${Number(u.id||0)})">
            ${avHtml}
            <div style="flex:1; min-width:0;">
              ${nameHtml}
              <div style="font-size:12px; color:var(--text-sub);">ID: ${escapeHtml(String(u.id||''))}</div>
            </div>
            <div style="color:var(--primary); font-weight:700;">发送</div>
          </div>
        `;
    }).join('');
}

async function forwardToUser(peerUserId){
    if (!peerUserId) return;
    const q = questions[currentIndex];
    const qid = q ? (q.getAttribute('data-id') || '') : '';
    if (!qid) { showToast('题目ID获取失败'); return; }

    try {
        // 1) 创建/复用会话
        const cRes = await fetch('/api/chat/conversations/create', {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ peer_user_id: peerUserId })
        });
        const cJs = await cRes.json();
        if (!cRes.ok || cJs.status !== 'success') { showToast(cJs.message || '创建会话失败'); return; }
        const cid = cJs.conversation_id;

        // 2) 发送“题目卡片”消息
        const sRes = await fetch('/api/chat/messages/send_question', {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ conversation_id: cid, question_id: Number(qid) })
        });
        const sJs = await sRes.json();
        if (!sRes.ok || sJs.status !== 'success') { showToast(sJs.message || '转发失败'); return; }

        showToast('已转发');
        closeForwardModal();
    } catch(e) {
        showToast('转发失败');
    }
}

// ===== 题目编辑（管理员/科目管理员） =====
function closeEditQuestionModal(e){
    if (e) {
        // 点击遮罩关闭
        if (e.target && e.target.id !== 'editQuestionOverlay') return;
    }
    const ov = document.getElementById('editQuestionOverlay');
    if (!ov) return;
    if (ov.dataset && ov.dataset.saving === '1') return;
    ov.style.display = 'none';
}

function getEditOptionKeysFromQuestion(qEl){
    const keys = [];
    try {
        qEl.querySelectorAll('.options-container .option-card label[data-opt]').forEach(label => {
            const k = (label.getAttribute('data-opt') || '').trim();
            if (k && !keys.includes(k)) keys.push(k);
        });
        // 兜底：传统布局
        if (!keys.length) {
            qEl.querySelectorAll('.options.mc-options label[data-opt]').forEach(label => {
                const k = (label.getAttribute('data-opt') || '').trim();
                if (k && !keys.includes(k)) keys.push(k);
            });
        }
    } catch(e) {}
    return keys;
}

function buildEditOptionsText(qEl, keys){
    try {
        return (keys || []).map(k => {
            const el =
                qEl.querySelector(`.options-container label[data-opt="${k}"] [data-opt-text]`) ||
                qEl.querySelector(`label[data-opt="${k}"] [data-opt-text]`);
            const val = el ? ((el.innerText || el.textContent || '').trim()) : '';
            return `${k}. ${val}`.trim();
        }).join('\n');
    } catch(e) {
        return '';
    }
}

function setEditQuestionSaving(on){
    const ov = document.getElementById('editQuestionOverlay');
    if (ov && ov.dataset) ov.dataset.saving = on ? '1' : '0';
    const btn = document.getElementById('editQuestionSaveBtn');
    if (btn) {
        btn.disabled = !!on;
        btn.textContent = on ? '保存中...' : '保存';
    }
}

function openEditQuestionModal(){
    const ov = document.getElementById('editQuestionOverlay');
    if (!ov) { showToast('编辑弹窗未加载'); return; }
    const q = questions[currentIndex];
    if (!q) { showToast('未找到当前题目'); return; }

    const qid = (q.getAttribute('data-id') || '').toString().trim();
    const qtype = (q.getAttribute('data-type') || '').toString().trim();
    if (!qid) { showToast('题目ID获取失败'); return; }

    ov.dataset.qid = qid;
    ov.dataset.qtype = qtype;

    const meta = document.getElementById('editQuestionMeta');
    if (meta) meta.textContent = `ID: ${qid} · 题型: ${qtype} · 第 ${currentIndex + 1} 题 / ${totalQuestions}`;

    const contentTa = document.getElementById('editQuestionContent');
    if (contentTa) {
        const el = q.querySelector('.question-layout-traditional .q-content') || q.querySelector('.q-content');
        contentTa.value = el ? ((el.innerText || el.textContent || '').trim()) : '';
    }

    const ansInp = document.getElementById('editQuestionAnswer');
    if (ansInp) ansInp.value = (q.getAttribute('data-answer') || '').toString();

    const expTa = document.getElementById('editQuestionExplanation');
    if (expTa) {
        const el = q.querySelector('.quiz-card.card-explain .answer');
        expTa.value = el ? ((el.innerText || el.textContent || '').toString()) : '';
    }

    const optWrap = document.getElementById('editQuestionOptionsWrap');
    const optTa = document.getElementById('editQuestionOptions');
    if (optWrap && optTa) {
        const show = (qtype === '选择题' || qtype === '多选题');
        optWrap.style.display = show ? 'flex' : 'none';
        if (show) {
            const keys = getEditOptionKeysFromQuestion(q);
            ov.dataset.optionKeys = keys.join(',');
            optTa.value = buildEditOptionsText(q, keys);
        } else {
            ov.dataset.optionKeys = '';
            optTa.value = '';
        }
    }

    setEditQuestionSaving(false);
    ov.style.display = 'flex';
    try { if (contentTa) contentTa.focus(); } catch(e) {}
}

function parseOptionsTextForEdit(optionsText){
    const lines = (optionsText || '').toString().split('\n').map(x => x.trim()).filter(Boolean);
    const options = [];
    for (const line of lines) {
        const m = line.match(/^([A-Za-z0-9]{1,3})\s*[、.．:：]\s*(.+)$/);
        if (m) {
            const key = (m[1] || '').trim().slice(0, 1).toUpperCase();
            const value = (m[2] || '').trim();
            if (key || value) options.push({ key, value });
            continue;
        }
        const first = line.slice(0, 1).toUpperCase();
        if (first && 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.includes(first)) {
            const rest = line.slice(1).replace(/^[\s:：.,、]+/, '').trim();
            options.push({ key: first, value: rest || line });
            continue;
        }
        options.push({ key: '', value: line });
    }

    // 补齐缺失 key（仅兜底）
    if (options.some(x => !(x.key || '').trim())) {
        const used = new Set(options.map(x => (x.key || '').trim().toUpperCase()).filter(Boolean));
        const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        let p = 0;
        options.forEach(x => {
            if ((x.key || '').trim()) return;
            while (p < letters.length && used.has(letters[p])) p += 1;
            const nextKey = letters[p] || '';
            if (nextKey) {
                x.key = nextKey;
                used.add(nextKey);
                p += 1;
            }
        });
    }

    return options;
}

function applyUpdatedQuestionToDom(qid, updated){
    const qEl = document.querySelector(`.question-box[data-id="${qid}"]`);
    if (!qEl) return;

    try {
        if (updated && typeof updated.q_type === 'string' && updated.q_type) {
            qEl.setAttribute('data-type', updated.q_type);
        }
        if (updated && updated.answer != null) {
            qEl.setAttribute('data-answer', String(updated.answer));
        }
        if (updated && updated.content != null) {
            qEl.querySelectorAll('.q-content').forEach(el => { el.textContent = String(updated.content); });
        }

        // 更新选项文本（仅支持保持原有 A/B/C... 数量不变的编辑）
        const qType = (updated && updated.q_type) ? updated.q_type : (qEl.getAttribute('data-type') || '');
        if ((qType === '选择题' || qType === '多选题') && Array.isArray(updated && updated.options)) {
            (updated.options || []).forEach(opt => {
                const key = (opt && opt.key != null) ? String(opt.key).trim() : '';
                const val = (opt && opt.value != null) ? String(opt.value) : '';
                if (!key) return;
                qEl.querySelectorAll(`label[data-opt="${key}"] [data-opt-text]`).forEach(span => {
                    span.textContent = val;
                });
            });
        }

        // 题内答案/解析卡片（用于 dock 渲染）
        const ansSpan = qEl.querySelector('.quiz-card.card-answer .answer.correct');
        if (ansSpan) ansSpan.textContent = String((updated && updated.answer) || '');

        const explainText = ((updated && updated.explanation) || '').toString();
        let explainCard = qEl.querySelector('.quiz-card.card-explain');
        if (explainText.trim()) {
            if (!explainCard) {
                const div = document.createElement('div');
                div.className = 'quiz-card card-explain';
                div.style.display = 'none';
                div.innerHTML = `
                    <div class="analysis-title">
                        <span class="dot" aria-hidden="true"></span>
                        <strong>解析</strong>
                    </div>
                    <p><span class="answer"></span></p>
                `;
                qEl.appendChild(div);
                explainCard = div;
            }
            const exSpan = explainCard.querySelector('.answer');
            if (exSpan) exSpan.textContent = explainText;
        } else if (explainCard) {
            explainCard.remove();
        }

        // 如果当前正在展示 dock，刷新内容
        try { renderAnswerExplainFromQuestion(qEl); } catch(e) {}
    } catch(e) {}
}

async function submitEditQuestion(){
    const ov = document.getElementById('editQuestionOverlay');
    if (!ov) return;
    if (ov.dataset && ov.dataset.saving === '1') return;

    const qid = Number((ov.dataset && ov.dataset.qid) ? ov.dataset.qid : 0);
    const qtype = (ov.dataset && ov.dataset.qtype) ? ov.dataset.qtype : '';
    if (!qid) { showToast('题目ID异常'); return; }

    const contentTa = document.getElementById('editQuestionContent');
    const content = contentTa ? (contentTa.value || '').toString().trim() : '';
    if (!content) { showToast('题干不能为空'); return; }

    const ansInp = document.getElementById('editQuestionAnswer');
    const answer = ansInp ? (ansInp.value || '').toString().trim() : '';
    const expTa = document.getElementById('editQuestionExplanation');
    const explanation = expTa ? (expTa.value || '').toString() : '';

    let options = undefined;
    if (qtype === '选择题' || qtype === '多选题') {
        const optTa = document.getElementById('editQuestionOptions');
        const optionsText = optTa ? (optTa.value || '').toString() : '';
        const parsed = parseOptionsTextForEdit(optionsText);
        if (!parsed.length) { showToast('请填写选项'); return; }

        // 为了避免重建 DOM，这里要求选项 key 集合保持不变（数量不变）
        const allowedKeys = (ov.dataset && ov.dataset.optionKeys) ? ov.dataset.optionKeys.split(',').map(x => x.trim()).filter(Boolean) : [];
        if (allowedKeys.length) {
            const setA = new Set(allowedKeys);
            const setB = new Set(parsed.map(x => (x.key || '').trim()).filter(Boolean));
            let mismatch = (setA.size !== setB.size);
            if (!mismatch) {
                for (const k of setA) { if (!setB.has(k)) { mismatch = true; break; } }
            }
            if (mismatch) {
                showToast('选项数量/标记需保持不变（可在题库管理中新增/删除选项）');
                return;
            }
        }
        options = parsed;
    }

    setEditQuestionSaving(true);
    try {
        const res = await fetch(`/api/quiz/questions/${qid}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ content, q_type: qtype, options, answer, explanation })
        });
        const js = await res.json();
        if (!res.ok || !js || js.status !== 'success') {
            showToast((js && js.message) || '保存失败');
            setEditQuestionSaving(false);
            return;
        }

        applyUpdatedQuestionToDom(qid, js.data);
        setEditQuestionSaving(false);
        showToast('已保存');
        closeEditQuestionModal();
    } catch(e) {
        setEditQuestionSaving(false);
        showToast('保存失败');
    }
}

// ===== 题目标签（用户私有） =====
const tagModalState = {
    open: false,
    qid: null,
    allTags: [],
    selected: [],
    saving: false
};

function getCurrentQuestionId(){
    try {
        const q = questions[currentIndex];
        const qid = q ? (q.getAttribute('data-id') || '') : '';
        return qid ? String(qid) : '';
    } catch(e) { return ''; }
}

function closeTagModal(e){
    if (e) {
        // 点击遮罩关闭
        if (e.target && e.target.id !== 'tagOverlay') return;
    }
    const ov = document.getElementById('tagOverlay');
    if (ov) ov.style.display = 'none';
    tagModalState.open = false;
    tagModalState.qid = null;
    tagModalState.selected = [];
    tagModalState.allTags = [];
}

async function openTagModal(){
    if (!LOGGED_IN) { showToast('请先登录后再使用标签'); return; }
    const qid = getCurrentQuestionId();
    if (!qid) { showToast('题目ID获取失败'); return; }

    const ov = document.getElementById('tagOverlay');
    if (!ov) return;
    ov.style.display = 'flex';
    tagModalState.open = true;
    tagModalState.qid = qid;

    const inp = document.getElementById('tagNewInput');
    if (inp) inp.value = '';

    await refreshTagModalData();

    try { if (inp) inp.focus(); } catch(e) {}
}

async function refreshTagModalData(){
    const qid = tagModalState.qid;
    if (!qid) return;

    const list = document.getElementById('tagChipList');
    if (list) list.innerHTML = `<div style="padding:10px 6px; color:var(--text-sub);">加载中...</div>`;

    try {
        const [tRes, qRes] = await Promise.all([
            fetch(`${IS_USER_BANK ? getUserBankApiPrefix() : '/api/quiz'}/tags`),
            fetch(`${IS_USER_BANK ? getUserBankApiPrefix() : '/api/quiz'}/questions/${encodeURIComponent(qid)}/tags`)
        ]);
        const tJs = await tRes.json();
        const qJs = await qRes.json();

        const allTags = (tRes.ok && tJs && tJs.status === 'success' && tJs.data && Array.isArray(tJs.data.tags))
            ? tJs.data.tags.map(x => x && x.name ? String(x.name) : '').filter(Boolean)
            : [];
        const selected = (qRes.ok && qJs && qJs.status === 'success' && qJs.data && Array.isArray(qJs.data.tags))
            ? qJs.data.tags.map(x => String(x)).filter(Boolean)
            : [];

        tagModalState.allTags = allTags;
        tagModalState.selected = selected;
        renderTagChips();
    } catch(e) {
        if (list) list.innerHTML = `<div style="padding:10px 6px; color:var(--text-sub);">加载失败</div>`;
    }
}

function renderTagChips(){
    const list = document.getElementById('tagChipList');
    if (!list) return;
    const tags = Array.isArray(tagModalState.allTags) ? tagModalState.allTags : [];
    const selected = Array.isArray(tagModalState.selected) ? tagModalState.selected : [];

    if (!tags.length) {
        list.innerHTML = `<div style="padding:10px 6px; color:var(--text-sub);">暂无标签，可在上方输入新建</div>`;
        return;
    }

    list.innerHTML = tags.map(name => {
        const on = selected.includes(name);
        return `<span class="tag-chip ${on ? 'active' : ''}" data-tag="${encodeURIComponent(name)}" onclick="toggleTagChip(this)">${on ? '<span class="tag-chip-check">✓</span>' : ''}${escapeHtml(name)}</span>`;
    }).join('');
}

async function toggleTagChip(el){
    const raw = el && el.dataset ? (el.dataset.tag || '') : '';
    let tag = '';
    try { tag = decodeURIComponent(String(raw || '')); } catch(e) { tag = String(raw || ''); }
    tag = tag.trim();
    if (!tag) return;

    const selected = Array.isArray(tagModalState.selected) ? tagModalState.selected.slice() : [];
    const idx = selected.indexOf(tag);
    if (idx >= 0) selected.splice(idx, 1);
    else selected.push(tag);

    tagModalState.selected = selected;
    renderTagChips();
    await saveQuestionTagsFromModal();
}

async function saveQuestionTagsFromModal(){
    const qid = tagModalState.qid;
    if (!qid) return;
    if (tagModalState.saving) return;

    tagModalState.saving = true;
    try {
        const res = await fetch(`${IS_USER_BANK ? getUserBankApiPrefix() : '/api/quiz'}/questions/${encodeURIComponent(qid)}/tags`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ tags: tagModalState.selected || [] })
        });
        const js = await res.json();
        if (!res.ok || !js || js.status !== 'success') {
            showToast((js && (js.message || js.msg)) || '保存失败');
            return;
        }
        const next = (js.data && Array.isArray(js.data.tags)) ? js.data.tags.map(x => String(x)).filter(Boolean) : [];
        tagModalState.selected = next;
        renderTagChips();
    } catch(e) {
        showToast('网络错误，请重试');
    } finally {
        tagModalState.saving = false;
    }
}

function onTagNewKey(e){
    if (e && e.key === 'Enter') {
        e.preventDefault();
        createTagFromModal();
    }
}

async function createTagFromModal(){
    if (!LOGGED_IN) { showToast('请先登录'); return; }
    const inp = document.getElementById('tagNewInput');
    const name = (inp && inp.value) ? inp.value.trim() : '';
    if (!name) { showToast('请输入标签名'); return; }

    try {
        const res = await fetch(`${IS_USER_BANK ? getUserBankApiPrefix() : '/api/quiz'}/tags`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ name })
        });
        const js = await res.json();
        if (!res.ok || !js || js.status !== 'success') {
            showToast((js && (js.message || js.msg)) || '创建失败');
            return;
        }
        const tags = (js.data && Array.isArray(js.data.tags)) ? js.data.tags.map(x => x && x.name ? String(x.name) : '').filter(Boolean) : [];
        tagModalState.allTags = tags;

        const created = (js.data && js.data.tag) ? String(js.data.tag) : name;
        if (!tagModalState.selected.includes(created)) {
            tagModalState.selected = (tagModalState.selected || []).concat([created]);
        }

        if (inp) inp.value = '';
        renderTagChips();
        await saveQuestionTagsFromModal();
    } catch(e) {
        showToast('网络错误，请重试');
    }
}

const totalQuestions = {{ questions|length }};
let currentIndex = 0;
let isWholeView = false;
let isSubmitted = false; // 标记是否已交卷

let timerSeconds = {{ duration * 60 if duration else 0 }};
let timerInterval;
let cachedOrder = null; // 缓存题目顺序，保存进度时需要保留

// ===== 悬浮球（Fab）+ 圆环菜单 + 可拖动 =====
const FAB_ENABLED_KEY = 'quiz_fab_enabled_v1';
const FAB_AUTO_NEXT_KEY = 'quiz_fab_auto_next';
const FAB_POS_KEY = 'quiz_fab_pos_v1';
const FAB_DOCK_LAYOUT_KEY = 'quiz_fab_dock_layout'; // 'default' | 'right' | 'left'
const FAB_HINT_DISMISSED_KEY = 'quiz_fab_hint_dismissed';
let fabOpen = false;

function isFabEnabled(){
    // 默认开启；用户在题库设置页关闭后写入 '0'
    return localStorage.getItem(FAB_ENABLED_KEY) !== '0';
}

function getDockLayout(){
    // 默认返回 'default'；用户设置后返回 'right' 或 'left'
    const layout = localStorage.getItem(FAB_DOCK_LAYOUT_KEY);
    return layout === 'right' || layout === 'left' ? layout : 'default';
}

function setDockLayout(layout){
    // layout: 'default' | 'right' | 'left'
    localStorage.setItem(FAB_DOCK_LAYOUT_KEY, layout);
}

function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

function getFabSize(){
    // 与 CSS .quiz-fab width/height 保持一致
    return 56;
}

function isFabAutoNextEnabled(){
    return localStorage.getItem(FAB_AUTO_NEXT_KEY) === '1';
}
function setFabAutoNextEnabled(on){
    localStorage.setItem(FAB_AUTO_NEXT_KEY, on ? '1' : '0');
}

// ===== 错题本刷题：答对是否清除（移出错题本） =====
const CLEAR_MISTAKE_ON_CORRECT_KEY = 'quiz_clear_mistake_on_correct_v1'; // '1' | '0'（默认 1）

function isMistakesScope(){
    const params = new URLSearchParams(window.location.search);
    const sourceParam = (params.get('source') || '').toLowerCase();
    const m = String(mode || '').toLowerCase();
    return sourceParam === 'mistakes' || m === 'mistakes';
}

function isClearMistakeOnCorrectEnabled(){
    try { return localStorage.getItem(CLEAR_MISTAKE_ON_CORRECT_KEY) !== '0'; } catch(e) { return true; }
}

function setClearMistakeOnCorrectEnabled(on){
    try { localStorage.setItem(CLEAR_MISTAKE_ON_CORRECT_KEY, on ? '1' : '0'); } catch(e) {}
}

function getClearMistakeOnCorrectForRequest(){
    return isMistakesScope() ? isClearMistakeOnCorrectEnabled() : true;
}

function updateMistakeClearOnCorrectUI(){
    const btn = document.getElementById('btnMistakeClearOnCorrect');
    if (!btn) return;
    const on = getClearMistakeOnCorrectForRequest();
    btn.setAttribute('aria-pressed', on ? 'true' : 'false');
    btn.title = on ? '答对将从错题本移除' : '答对将保留在错题本';
    btn.textContent = on ? '答对移出' : '答对保留';
}

function toggleMistakeClearOnCorrect(){
    if (!isMistakesScope()) return;
    const next = !isClearMistakeOnCorrectEnabled();
    setClearMistakeOnCorrectEnabled(next);
    updateMistakeClearOnCorrectUI();
    showToast(next ? '已开启：答对移出错题本' : '已关闭：答对移出错题本');
}

function saveFabPos(left, top){
    try { localStorage.setItem(FAB_POS_KEY, JSON.stringify({ left, top })); } catch(e) {}
}
function loadFabPos(){
    try {
        const raw = localStorage.getItem(FAB_POS_KEY);
        if (!raw) return null;
        const js = JSON.parse(raw);
        if (!js || typeof js.left !== 'number' || typeof js.top !== 'number') return null;
        return js;
    } catch(e) { return null; }
}

function calcDefaultFabPos(){
    const size = getFabSize();
    const rightGap = 14;
    const bottomGap = 84;
    const left = Math.max(8, window.innerWidth - rightGap - size);
    const top = Math.max(8, window.innerHeight - bottomGap - size);
    return { left, top };
}

function normalizeFabPos(pos){
    const size = getFabSize();
    const margin = 8;
    const maxLeft = window.innerWidth - size - margin;
    const maxTop = window.innerHeight - size - margin;
    return {
        left: clamp(pos.left, margin, Math.max(margin, maxLeft)),
        top: clamp(pos.top, margin, Math.max(margin, maxTop))
    };
}

function applyFabPos(left, top){
    const fab = document.getElementById('quizFab');
    const menu = document.getElementById('quizFabMenu');
    if (!fab || !menu) return;

    fab.style.left = `${left}px`;
    fab.style.top = `${top}px`;
    fab.style.right = 'auto';
    fab.style.bottom = 'auto';

    menu.style.left = `${left}px`;
    menu.style.top = `${top}px`;
    menu.style.right = 'auto';
    menu.style.bottom = 'auto';
}

function updateFabUI(){
    const fab = document.getElementById('quizFab');
    const menu = document.getElementById('quizFabMenu');
    if (!fab || !menu) return;

    fab.classList.toggle('open', fabOpen);
    menu.classList.toggle('open', fabOpen);
    menu.setAttribute('aria-hidden', fabOpen ? 'false' : 'true');

    const btnAuto = menu.querySelector('.quiz-fab-item[data-action="autoNext"] .quiz-fab-icon');
    if (btnAuto) btnAuto.textContent = isFabAutoNextEnabled() ? '✓✓' : '✓';

    // 更新布局切换按钮状态
    const btnLayout = menu.querySelector('.quiz-fab-item[data-action="toggleLayout"]');
    if (btnLayout) {
        const layout = getDockLayout();
        const iconEl = btnLayout.querySelector('.quiz-fab-icon');
        btnLayout.classList.toggle('active', layout !== 'default');
        
        // 根据布局状态显示不同的图标和提示
        if (layout === 'right') {
            if (iconEl) iconEl.textContent = '→';
            btnLayout.title = '切换为左侧布局';
            btnLayout.setAttribute('aria-label', '切换为左侧布局');
        } else if (layout === 'left') {
            if (iconEl) iconEl.textContent = '←';
            btnLayout.title = '恢复默认布局';
            btnLayout.setAttribute('aria-label', '恢复默认布局');
        } else {
            if (iconEl) iconEl.textContent = '⇄';
            btnLayout.title = '切换布局';
            btnLayout.setAttribute('aria-label', '切换布局');
        }
    }

    // 根据贴边方向调整菜单展开方向（贴左→向右展开；贴右→向左展开）
    try {
        const rect = fab.getBoundingClientRect();
        const size = getFabSize();
        const centerX = rect.left + size / 2;
        const isLeft = centerX < (window.innerWidth / 2);
        menu.classList.toggle('edge-left', isLeft);
    } catch(e) {}

    // 确保菜单始终跟随悬浮球
    try {
        const rect = fab.getBoundingClientRect();
        const pos = normalizeFabPos({ left: rect.left, top: rect.top });
        applyFabPos(pos.left, pos.top);
    } catch(e) {}
}

function toggleFab(open){
    const wasOpen = fabOpen;
    fabOpen = typeof open === 'boolean' ? open : !fabOpen;
    
    // 首次打开悬浮球时，自动永久关闭悬浮球提示（避免干扰）
    if (!wasOpen && fabOpen) {
        const fabHint = document.getElementById('fabHint');
        if (fabHint && fabHint.style.display !== 'none') {
            dismissFabHintPermanently();
        }
    }
    
    updateFabUI();
}

async function toggleCurrentFavorite(){
    if (!LOGGED_IN) { showToast('请先登录'); return; }
    const q = questions[currentIndex];
    const favBtn = q ? q.querySelector('.fav-btn') : null;
    if (favBtn && typeof favBtn.click === 'function') {
        favBtn.click();
        return;
    }
    showToast('收藏按钮不可用');
}

// Web 端 AI 解析：点击 AI 仅开关卡片；“重新生成”才会再次调用接口
const aiExplainState = {
    qid: null,
    explain: '',
    open: false,
    loading: false,
    lastReqId: 0
};

function getCurrentAiPayload(){
    const q = questions[currentIndex];
    if (!q) return null;
    const qidRaw = q.getAttribute('data-id') || '';
    const qtype = q.getAttribute('data-type') || '';
    const contentEl = q.querySelector('.q-content');
    const content = contentEl ? (contentEl.innerText || '').trim() : '';

    let options = [];
    try {
        const preferCard = document.body.classList.contains('quiz-layout-card');
        if (preferCard) {
            const labels = q.querySelectorAll('.question-layout-card .option-card label');
            if (labels && labels.length) {
                options = Array.from(labels).map(lab => {
                    const keyRaw = (lab.querySelector('.option-key') || {}).innerText || '';
                    const valRaw = (lab.querySelector('.option-text') || {}).innerText || '';
                    const key = (keyRaw || '').toString().replace(/\s+/g, ' ').trim().replace(/\.$/, '');
                    const value = (valRaw || '').toString().trim();
                    return { key, value };
                });
            }
        } else {
            const optNodes = q.querySelectorAll('.option');
            if (optNodes && optNodes.length) {
                options = Array.from(optNodes).map(node => {
                    const key = (node.querySelector('.opt-key') || {}).innerText || '';
                    const val = (node.querySelector('.opt-text') || {}).innerText || node.innerText || '';
                    return { key: key.trim(), value: val.trim() };
                });
            }
        }
    } catch(e) {}

    const qid = qidRaw ? Number(qidRaw) : null;
    return { qid, qtype, content, options };
}

function getAIExplainHost(){
    const preferCard = document.body.classList.contains('quiz-layout-card');
    const q = questions[currentIndex];
    if (preferCard && q) {
        const host = q.querySelector('.ai-inline-host');
        if (host) return host;
    }
    return document.getElementById('aiExplainCard') || document.getElementById('explainCard');
}

function syncAnswerAiButtonState(){
    try {
        const q = questions[currentIndex];
        if (!q) return;
        const btn = q.querySelector('.answer-ai-btn');
        if (!btn) return;
        const open = !!aiExplainState.open;
        btn.classList.toggle('active', open);
        btn.setAttribute('aria-pressed', open ? 'true' : 'false');
    } catch(e) {}
}

function renderAIExplainCard({ loading, explainText }){
    const host = getAIExplainHost();
    if (!host) return;

    const safeText = (explainText || '').toString();
    const loadingText = loading ? '生成中…' : '';

    host.style.display = 'block';
    host.innerHTML = `
        <div class="ai-explain-card">
          <div class="ai-explain-header">
            <div class="ai-explain-title">AI 解析</div>
            <div class="ai-explain-actions">
              ${loading ? `<div class="ai-explain-loading">${loadingText}</div>` : ``}
              <button class="ai-explain-btn" type="button" id="aiExplainRegenerateBtn" ${loading ? 'disabled' : ''}>重新生成</button>
              <button class="ai-explain-btn" type="button" id="aiExplainCopyBtn" ${loading ? 'disabled' : ''}>复制</button>
            </div>
          </div>
          <div class="ai-explain-body">
            ${loading
                ? `<div class="ai-explain-placeholder">请稍候</div>`
                : `<div class="ai-explain-text">${escapeHtmlWithBreaks(safeText || '暂无内容')}</div>`
            }
          </div>
        </div>
    `;

    const regenBtn = document.getElementById('aiExplainRegenerateBtn');
    if (regenBtn) {
        regenBtn.onclick = async function(){
            await requestAIExplain({ force: true });
        };
    }

    const copyBtn = document.getElementById('aiExplainCopyBtn');
    if (copyBtn) {
        copyBtn.onclick = async function(){
            try { await navigator.clipboard.writeText(safeText || ''); showToast('已复制'); }
            catch(e) { showToast('复制失败'); }
        };
    }
}

function hideAIExplainCard({ clear = false } = {}){
    const host = getAIExplainHost();
    if (!host) return;
    host.style.display = 'none';
    host.classList.remove('show');
    if (clear) host.innerHTML = '';
    aiExplainState.open = false;
    syncAnswerAiButtonState();
    updateDockEmptyState();
}

function showAIExplainCard(){
    const host = getAIExplainHost();
    if (!host) return;
    host.style.display = 'block';
    host.classList.add('show');
    aiExplainState.open = true;
    syncAnswerAiButtonState();
    updateDockEmptyState();
}

async function requestAIExplain({ force = false } = {}){
    if (!LOGGED_IN) { showToast('请先登录'); return; }
    const payload = getCurrentAiPayload();
    if (!payload) return;

    const { qid, qtype, content, options } = payload;
    if (!force && aiExplainState.explain && aiExplainState.qid === qid) {
        renderAIExplainCard({ loading: false, explainText: aiExplainState.explain });
        return;
    }

    showAIExplainCard();
    aiExplainState.loading = true;
    renderAIExplainCard({ loading: true, explainText: '' });

    const reqId = ++aiExplainState.lastReqId;
    try {
        const res = await fetch('/api/ai/explain', {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ question_id: qid, q_type: qtype, content, options })
        });
        const js = await res.json();
        if (reqId !== aiExplainState.lastReqId) return; // 被新的请求覆盖
        if (!res.ok || !js || js.status !== 'success') {
            showToast((js && js.message) || 'AI 解析失败');
            aiExplainState.loading = false;
            renderAIExplainCard({ loading: false, explainText: 'AI 解析失败，请稍后重试。' });
            return;
        }
        const explain = (js.data && js.data.explain) ? js.data.explain : '';
        aiExplainState.qid = qid;
        aiExplainState.explain = (explain || '').toString();
        aiExplainState.loading = false;
        renderAIExplainCard({ loading: false, explainText: aiExplainState.explain });
    } catch(e) {
        if (reqId !== aiExplainState.lastReqId) return;
        aiExplainState.loading = false;
        showToast('AI 解析失败');
        renderAIExplainCard({ loading: false, explainText: 'AI 解析失败，请检查网络或稍后重试。' });
    }
}

async function toggleAIExplain(){
    const host = getAIExplainHost();
    if (!host) return;
    if (IS_USER_BANK) { showToast('个人题库暂不支持AI解析'); return; }
    const isOpen = host.style.display !== 'none';
    if (isOpen) {
        // 关闭但保留内容，避免再次点击触发重新生成
        hideAIExplainCard({ clear: false });
        return;
    }

    showAIExplainCard();
    const payload = getCurrentAiPayload();
    const qid = payload ? payload.qid : null;
    if (aiExplainState.explain && aiExplainState.qid === qid) {
        renderAIExplainCard({ loading: false, explainText: aiExplainState.explain });
        return;
    }
    await requestAIExplain({ force: true });
}

function bindFab(){
    const fab = document.getElementById('quizFab');
    const menu = document.getElementById('quizFabMenu');
    if (!fab || !menu) return;

    // 初始位置（优先读取已保存的位置）
    const saved = loadFabPos();
    const initial = normalizeFabPos(saved || calcDefaultFabPos());
    applyFabPos(initial.left, initial.top);

    // 拖拽（pointer events）
    let dragging = false;
    let moved = false;
    let startX = 0;
    let startY = 0;
    let startLeft = 0;
    let startTop = 0;

    fab.addEventListener('pointerdown', (e)=>{
        dragging = true;
        moved = false;
        startX = e.clientX;
        startY = e.clientY;
        const rect = fab.getBoundingClientRect();
        startLeft = rect.left;
        startTop = rect.top;

        try { fab.setPointerCapture(e.pointerId); } catch(err) {}
    });

    fab.addEventListener('pointermove', (e)=>{
        if (!dragging) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        if (!moved && Math.abs(dx) + Math.abs(dy) > 6) {
            moved = true;
            // 仅当用户确实在拖动时关闭菜单（否则点击“二次关闭”会被 pointerdown 抢先关掉又被 click 重新打开）
            if (fabOpen) toggleFab(false);
        }
        const next = normalizeFabPos({ left: startLeft + dx, top: startTop + dy });
        applyFabPos(next.left, next.top);
    });

    const endDrag = (e)=>{
        if (!dragging) return;
        dragging = false;
        const rect = fab.getBoundingClientRect();
        let next = normalizeFabPos({ left: rect.left, top: rect.top });

        // 自动吸边（左右贴边）+ 平滑动画（仅吸附时生效）
        const size = getFabSize();
        const margin = 8;
        const maxLeft = window.innerWidth - size - margin;
        const snapLeft = margin;
        const snapRight = Math.max(margin, maxLeft);
        const centerX = next.left + size / 2;
        next.left = (centerX < window.innerWidth / 2) ? snapLeft : snapRight;

        // 只在吸附时开启 transition，避免拖动过程有延迟
        try {
            fab.style.transition = 'left .16s ease, top .16s ease, transform .22s ease, box-shadow .22s ease, background-color .22s ease';
            const menu = document.getElementById('quizFabMenu');
            if (menu) menu.style.transition = 'left .16s ease, top .16s ease';
        } catch(e) {}

        applyFabPos(next.left, next.top);
        saveFabPos(next.left, next.top);

        // 动画结束后恢复默认（防止拖动时“粘滞”）
        setTimeout(()=>{
            try {
                fab.style.transition = '';
                const menu = document.getElementById('quizFabMenu');
                if (menu) menu.style.transition = '';
            } catch(e) {}
        }, 220);

        // 如果是拖动导致的 pointerup，阻止随后 click 打开菜单
        if (moved) {
            fab._suppressClickOnce = true;
            setTimeout(()=>{ fab._suppressClickOnce = false; }, 0);
        }

        try { fab.releasePointerCapture(e.pointerId); } catch(err) {}
    };

    fab.addEventListener('pointerup', endDrag);
    fab.addEventListener('pointercancel', endDrag);

    // 点击打开/关闭菜单
    fab.addEventListener('click', (e)=>{
        if (fab._suppressClickOnce) return;
        e.preventDefault();
        e.stopPropagation();
        toggleFab();
    });

    // 菜单按钮
    menu.querySelectorAll('.quiz-fab-item').forEach(btn => {
        btn.addEventListener('click', async (e)=>{
            e.preventDefault();
            e.stopPropagation();
            const action = btn.dataset.action;
            if (!action) return;

            if (action === 'autoNext') {
                // 考试回顾（已交卷）禁用
                if (mode === 'exam' && EXAM_SUBMITTED) {
                    showToast('回顾模式：该功能不可用');
                    toggleFab(false);
                    return;
                }
                const next = !isFabAutoNextEnabled();
                setFabAutoNextEnabled(next);
                updateFabUI();
                showToast(next ? '已开启：答对自动切题' : '已关闭：答对自动切题');
                return;
            }

            if (action === 'aiExplain') {
                await toggleAIExplain();
                toggleFab(false);
                return;
            }

            if (action === 'bookmark') {
                await toggleCurrentFavorite();
                toggleFab(false);
                return;
            }

            if (action === 'toggleLayout') {
                const currentLayout = getDockLayout();
                let nextLayout;
                if (currentLayout === 'default') {
                    nextLayout = 'right';
                } else if (currentLayout === 'right') {
                    nextLayout = 'left';
                } else {
                    nextLayout = 'default';
                }
                setDockLayout(nextLayout);
                updateFabUI();
                // 重新应用布局到当前题目
                showQuestion(currentIndex);
                const messages = {
                    'default': '已恢复默认布局',
                    'right': '已切换为右侧布局',
                    'left': '已切换为左侧布局'
                };
                showToast(messages[nextLayout]);
                toggleFab(false);
                return;
            }

            if (action === 'clearCurrent') {
                clearCurrentQuestionProgress();
                toggleFab(false);
                return;
            }

            if (action === 'editQuestion') {
                const q = questions[currentIndex];
                if (!q) { showToast('未找到当前题目'); toggleFab(false); return; }
                openEditQuestionModal();
                toggleFab(false);
                return;
            }
        });
    });

    document.addEventListener('click', ()=>{ if (fabOpen) toggleFab(false); });
    document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape' && fabOpen) toggleFab(false); });

    // resize 时保证悬浮球不出界 + 保持吸边
    window.addEventListener('resize', ()=>{
        const cur = loadFabPos() || calcDefaultFabPos();
        let n = normalizeFabPos(cur);
        const size = getFabSize();
        const margin = 8;
        const maxLeft = window.innerWidth - size - margin;
        // 若当前更靠左/右，则吸附到对应边
        const centerX = n.left + size / 2;
        n.left = (centerX < window.innerWidth / 2) ? margin : Math.max(margin, maxLeft);
        applyFabPos(n.left, n.top);
        saveFabPos(n.left, n.top);
    });

    updateFabUI();
}

async function init() {
    if (localStorage.getItem('theme') === 'dark') document.body.classList.add('dark-mode');
    updateMistakeClearOnCorrectUI();
    
    // 题目页统一使用“卡片布局”（对齐小程序样式）
    document.body.classList.add('quiz-layout-card');
    try { localStorage.setItem('quiz_layout_theme_v1', 'card'); } catch(e) {}

    // 卡片布局：用底部“设置”替代悬浮球功能，直接隐藏悬浮球与菜单
    try {
        const fab = document.getElementById('quizFab');
        const menu = document.getElementById('quizFabMenu');
        if (fab) fab.style.display = 'none';
        if (menu) menu.style.display = 'none';
    } catch(e) {}
    // 仍保留快捷键提示（fabHint 会在 showFabHint 内自动跳过）
    setTimeout(showNextHint, 500);
    // 进度加载：考试模式（未交卷）也启用，与刷题/背题一致（localStorage + /api/progress）
    if (mode !== 'exam' || (mode === 'exam' && !EXAM_SUBMITTED)) {
        await preloadProgress();
    }
    
    // 如果是乱序模式且 cachedOrder 还没有被设置，从当前 DOM 中收集题目顺序
    // 这确保了即使服务器获取失败，也能正确保存顺序
    const params = new URLSearchParams(window.location.search);
    const isShuffleMode = params.get('shuffle_questions') === '1';
    if (isShuffleMode && !cachedOrder && questions.length > 0) {
        cachedOrder = Array.from(questions).map(q => parseInt(q.getAttribute('data-id')));
    }

    if (mode === 'exam') {
        if (EXAM_SUBMITTED) {
            isSubmitted = true;
            // 回顾模式：预填答案并展示解析
            applyReviewFromServer();
            const btnSubmit = document.getElementById('btn-submit-exam');
            if (btnSubmit) btnSubmit.style.display = 'none';
            const timerEl = document.getElementById('timer');
            if (timerEl) timerEl.style.display = 'none';
            const btnNext = document.getElementById('btn-next-exam');
            if (btnNext) btnNext.style.display = 'block';
        } else {
            // 进行中考试：恢复服务器草稿并启动自动保存
            // 注意：preloadProgress()/loadState() 已经先执行过，会恢复 currentIndex/本地答题输入。
            // 这里再用服务端草稿补齐（若本地为空），但不覆盖本地已输入的内容。
            applyDraftFromServer();
            startTimer();
            const btnNext = document.getElementById('btn-next-exam');
            if (btnNext) btnNext.style.display = 'block';
            scheduleAutoSave();
        }
    }

    showQuestion(currentIndex);
    syncFixedBarsMetrics();
}

async function preloadProgress(){
    const key = progressKey();

    // 登录用户优先从服务器拉取进度
    if (LOGGED_IN) {
        try {
            const encodedKey = encodeURIComponent(key);
            const res = await fetch(`/api/progress?key=${encodedKey}`);
            if (res.ok) {
                const js = await res.json();
                if (js.status === 'success' && js.data) {
                    // 比较时间戳,使用最新的进度
                    const serverData = js.data;
                    const localDataStr = localStorage.getItem(key);

                    // 缓存服务器的题目顺序（如果有）
                    if (serverData.order && Array.isArray(serverData.order)) {
                        cachedOrder = serverData.order;
                    }

                    if (localDataStr) {
                        try {
                            const localData = JSON.parse(localDataStr);
                            const serverTime = serverData.timestamp || 0;
                            const localTime = localData.timestamp || 0;

                            // 使用时间戳较新的数据，但始终保留order字段
                            if (serverTime > localTime) {
                                localStorage.setItem(key, JSON.stringify(serverData));
                            } else {
                                // 本地更新,同步到服务器，但保留服务器的order
                                if (localTime > serverTime) {
                                    // 合并：保留服务器的order到本地数据
                                    if (cachedOrder && !localData.order) {
                                        localData.order = cachedOrder;
                                        localStorage.setItem(key, JSON.stringify(localData));
                                    }
                                    syncToServer(localData);
                                }
                            }
                        } catch(e) {
                            // 解析失败,使用服务器数据
                            localStorage.setItem(key, JSON.stringify(serverData));
                        }
                    } else {
                        // 本地无数据,使用服务器数据
                        localStorage.setItem(key, JSON.stringify(serverData));
                    }
                } else {
                }
            }
        } catch(e) {
            console.error('[进度加载] 加载服务器进度失败:', e);
        }
    }
    loadState();
}

function startTimer() {
    const timerEl = document.getElementById('timer');
    timerInterval = setInterval(() => {
        timerSeconds--;
        if (timerSeconds <= 0) {
            clearInterval(timerInterval);
            alert('考试时间到！系统将自动交卷。');
            submitExam(true); 
            return;
        }
        const h = Math.floor(timerSeconds / 3600).toString().padStart(2,'0');
        const m = Math.floor((timerSeconds % 3600) / 60).toString().padStart(2,'0');
        const s = (timerSeconds % 60).toString().padStart(2,'0');
        timerEl.innerText = `${h}:${m}:${s}`;
    }, 1000);
}

function markAnswered(index) {
    // 考试模式：题目列表标注“已答/未答”
    // 兼容：不要强依赖题目容器 id = q-{index}（可能被重排/分页导致不一致）
    try {
        // 1) 优先从事件源 input 反查所属题目（最稳）
        let q = null;
        const ev = (typeof window !== 'undefined') ? window.event : null;
        const target = ev && ev.target ? ev.target : null;
        if (target && target.closest) {
            q = target.closest('.question-box');
        }

        // 2) 回退：按旧逻辑通过 id 查找
        if (!q) q = document.getElementById(`q-${index}`);
        if (!q) return;

        // 3) 以题目 DOM 自带 data-index 为准（若不存在则用入参 index）
        const realIndexStr = q.getAttribute('data-index');
        const realIndex = (realIndexStr !== null && realIndexStr !== '') ? Number(realIndexStr) : index;

        const item = document.getElementById(`list-item-${realIndex}`);
        if (!item) return;

        const type = q.getAttribute('data-type');
        if (hasAnswered(q, type)) {
            item.classList.add('answered');
        } else {
            item.classList.remove('answered');
        }
    } catch(e) {
        // 兜底：不要抛错影响考试流程
        try {
            const item = document.getElementById(`list-item-${index}`);
            if (item) item.classList.add('answered');
        } catch(_) {}
    }
}

function toggleWholeView() {
    isWholeView = !isWholeView;
    const container = document.getElementById('mainCard');
    const btn = document.getElementById('btn-whole-view');
    
    if (isWholeView) {
        container.classList.add('whole-view');
        btn.innerText = "↩ 返回单题";
        window.scrollTo(0, 0); // 滚回顶部
        
        if(mode === 'exam' && !isSubmitted) { // 只有没交卷时才显示交卷按钮
            let tempSubmit = document.getElementById('temp-submit');
            if(!tempSubmit) {
                tempSubmit = document.createElement('button');
                tempSubmit.id = 'temp-submit';
                tempSubmit.className = 'btn btn-submit';
                tempSubmit.style.display = 'block';
                tempSubmit.style.margin = '20px auto';
                tempSubmit.innerText = '📤 交卷';
                tempSubmit.onclick = () => submitExam();
                container.appendChild(tempSubmit);
            } else {
                tempSubmit.style.display = 'block';
            }
        }
    } else {
        container.classList.remove('whole-view');
        btn.innerText = "整卷预览";
        const tempSubmit = document.getElementById('temp-submit');
        if(tempSubmit) tempSubmit.style.display = 'none';
        showQuestion(currentIndex);
    }
}

function jumpTo(index) {
    if (isWholeView) {
        const el = document.getElementById('q-' + index);
        if(el) {
            el.scrollIntoView({behavior: 'smooth', block: 'center'});
            el.style.transition = 'background 0.3s';
            el.style.background = 'rgba(0,123,255,0.1)';
            setTimeout(() => el.style.background = 'transparent', 500);
        }
    } else {
        showQuestion(index);
    }
    toggleSidebar(); 
}

function showQuestion(index) {
    if (isWholeView) return; 

    questions.forEach(q => q.classList.remove('active'));
    questions[index].classList.add('active');
    
    listItems.forEach(item => item.classList.remove('active'));
    if(listItems[index]) {
        listItems[index].classList.add('active');
        listItems[index].scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    // 先更新当前索引，避免回顾模式下无法翻页
    currentIndex = index;

    const currentQ = questions[index];
    const type = currentQ.getAttribute('data-type');
    const answer = currentQ.getAttribute('data-answer');

    // 题目页已统一为小程序风格卡片布局；主观题（问答/简答/计算）使用左右分栏
    const mainArea = document.querySelector('.main-area');
    if (mainArea) {
        mainArea.classList.toggle('subjective-layout', isSubjectiveType(type));
    }

    // 答案/解析渲染：由 renderAnswerExplainFromQuestion 控制
    setupImageGallery(currentQ);

    // 自动聚焦填空题/主观题输入框
    const qType = currentQ.getAttribute('data-type');
    if (qType === '填空题' || isSubjectiveType(qType)) {
        const inputField = currentQ.querySelector('.main-input, textarea');
        if (inputField && !inputField.disabled) {
            // 动画结束后聚焦，以确保元素可见
            setTimeout(() => inputField.focus(), 400); 
        }
    }

    const btnPrev = document.getElementById('btn-prev');
    btnPrev.disabled = (index === 0);

    if (mode === 'exam') {
        const btnNextExam = document.getElementById('btn-next-exam');
        const btnSubmitExam = document.getElementById('btn-submit-exam');
        
        // 如果已交卷：回顾模式（显示答案/解析，禁用作答），同时更新进度条
        if (isSubmitted) {
            renderAnswerExplainFromQuestion(currentQ);

            if (btnNextExam) {
                btnNextExam.style.display = (index === totalQuestions - 1) ? 'none' : 'block';
            }
            if (btnSubmitExam) btnSubmitExam.style.display = 'none';

            // 回顾时的结果徽标：主观题不判对错，显示“待核对”
            if (isSubjectiveType(type)) {
                setAnswerResultBadge('pending');
            } else {
                try {
                    const inferredCorrect = judgeQuestion(currentQ, type, answer);
                    setAnswerResultBadge(inferredCorrect);
                } catch(e) {
                    setAnswerResultBadge(null);
                }
            }

            const plabel = document.getElementById('progress-label');
            if (plabel) plabel.innerText = `${currentIndex + 1} / ${totalQuestions}`;
            const pf = document.getElementById('progress-fill');
            if (pf) pf.style.width = ((currentIndex + 1) / totalQuestions * 100) + '%';
            const topTitle = document.getElementById('topbar-title');
            if (topTitle) topTitle.innerText = `${currentIndex + 1}/${totalQuestions}`;
            return;
        }

        if (index === totalQuestions - 1) {
            btnNextExam.style.display = 'none';
            btnSubmitExam.style.display = 'block';
        } else {
            btnNextExam.style.display = 'block';
            btnSubmitExam.style.display = 'none';
        }
    } else {
        const btnNext = document.getElementById('btn-next');
        
        if (mode === 'memo') {
            renderAnswerExplainFromQuestion(currentQ);
            if (btnNext) btnNext.style.display = 'block';
            updateBottomSubmitState(currentQ);
            updateMultiSubmitState(currentQ);
            fillAnswer(currentQ, type, answer);
            disableInputs(currentQ); 
        } else {
            // 默认：切题先隐藏；若该题已做过（正确/错误），自动展示答案/解析
            hideAnswerExplainDock();
            const hasResult = isQuestionAlreadyChecked(currentQ);
            if (hasResult) {
                renderAnswerExplainFromQuestion(currentQ);
            }

            if (btnNext) btnNext.style.display = 'block';
            updateBottomSubmitState(currentQ);
            updateSubjectiveSubmitState(currentQ);
            updateMultiSubmitState(currentQ);

            if (btnNext) {
                if (index === totalQuestions - 1) {
                    btnNext.innerText = "完成";
                    btnNext.onclick = finishQuiz;
                } else {
                    btnNext.innerText = "下一题";
                    btnNext.onclick = nextQuestion;
                }
            }
        }
    }

    currentIndex = index;
    const plabel = document.getElementById('progress-label');
    if (plabel) plabel.innerText = `${currentIndex + 1} / ${totalQuestions}`;
    const pf = document.getElementById('progress-fill');
    if (pf) pf.style.width = ((currentIndex + 1) / totalQuestions * 100) + '%';

    const topTitle = document.getElementById('topbar-title');
    if (topTitle) topTitle.innerText = `${currentIndex + 1}/${totalQuestions}`;
    
    // 保存进度：考试模式（未交卷）也保存，已交卷不再写进度
    if (mode !== 'exam' || (mode === 'exam' && !isSubmitted)) saveState();
}

function fillAnswer(q, type, answer) {
    if (type === '选择题' || type === '判断题' || type === '多选题') {
        q.querySelectorAll('input').forEach(input => {
            const label = input.parentElement;
            const optionCard = label ? label.closest('.option-card') : null;
            label.classList.remove('correct-opt');
            if (optionCard) optionCard.classList.remove('correct-opt', 'wrong-opt');
            // For choice questions, the value is the key ('A', 'B', etc.)
            // For judgment questions, the value is '正确' or '错误'
            if (answer.includes(input.value)) {
                label.classList.add('correct-opt');
                if (optionCard) optionCard.classList.add('correct-opt');
                input.checked = true;
            }
        });
    } else if (type === '填空题') {
        const inputs = q.querySelectorAll('.main-input');
        const correctBlanks = answer.split(';;').map(a => a.trim());

        inputs.forEach((input, i) => {
            // 默认填充每个空的第一个正确答案
            const firstCorrectAnswer = (correctBlanks[i] || '').split(';')[0].trim();
            input.value = firstCorrectAnswer;
            input.classList.add('input-correct');
        });
    }
}

function disableInputs(q) {
    q.classList.add('checked-mode');
    q.querySelectorAll('input, textarea').forEach(el => el.disabled = true);
}

function autoCheck() {
    // 方案A：选择题/判断题自动出结果；多选题/填空/问答保留"查看结果"按钮
    const currentQ = questions[currentIndex];
    if (!currentQ) return;
    const type = currentQ.getAttribute('data-type');
    if (type === '判断题' || (type === '选择题' && isAutoCheckType(type, currentQ))) {
        checkAnswer(false);
    }
    // 多选题不自动检查，需要用户点击"查看结果"按钮
}

// 判断题：隐藏原生 radio 后，用整行高亮来表现选中态
document.addEventListener('change', function(e){
    const t = e.target;
    if (!(t instanceof HTMLInputElement)) return;

    // 判断题（radio）：处理传统布局和卡片布局
    if (t.type === 'radio') {
        // 传统布局
        const wrap = t.closest('.tf-options');
        if (wrap) {
            const name = t.name;
            wrap.querySelectorAll(`input[type="radio"][name="${CSS.escape(name)}"]`).forEach(r => {
                const lab = r.closest('label');
                if (lab) lab.classList.toggle('selected', r.checked);
            });
        }
        // 卡片布局
        const cardWrap = t.closest('.tf-option-card');
        if (cardWrap) {
            const name = t.name;
            const container = cardWrap.closest('.options-container');
            if (container) {
                container.querySelectorAll(`input[type="radio"][name="${CSS.escape(name)}"]`).forEach(r => {
                    const card = r.closest('.option-card');
                    if (card) {
                        const lab = r.closest('label');
                        if (lab) {
                            lab.classList.toggle('selected', r.checked);
                            // 同时给选项卡片添加 selected 类，用于整体高亮
                            card.classList.toggle('selected', r.checked);
                        }
                    }
                });
            }
        }
        try {
            const qEl = t.closest('.question-box');
            updateBottomSubmitState(qEl);
            updateSubjectiveSubmitState(qEl);
            updateMultiSubmitState(qEl);
        } catch(e) {}
        return;
    }

    // 选择题（checkbox）：统一成判断题同款"整行高亮 + 左侧标记"
    if (t.type === 'checkbox') {
        // 传统布局
        const wrap = t.closest('.options');
        if (wrap && !wrap.classList.contains('tf-options')) {
            const lab = t.closest('label');
            if (lab) lab.classList.toggle('selected', t.checked);
        }
        // 卡片布局
        const cardWrap = t.closest('.option-card');
        if (cardWrap) {
            const lab = t.closest('label');
            if (lab) {
                lab.classList.toggle('selected', t.checked);
                // 同时给选项卡片添加 selected 类，用于整体高亮
                cardWrap.classList.toggle('selected', t.checked);
            }
        }
        try {
            const qEl = t.closest('.question-box');
            updateBottomSubmitState(qEl);
            updateSubjectiveSubmitState(qEl);
            updateMultiSubmitState(qEl);
        } catch(e) {}
        return;
    }
});

// 输入：用于动态启用/禁用“提交答案”（多选/填空）和主观题右侧提交按钮
document.addEventListener('input', function(e){
    const t = e.target;
    if (!(t instanceof HTMLInputElement || t instanceof HTMLTextAreaElement)) return;
    const qEl = t.closest ? t.closest('.question-box') : null;
    if (!qEl) return;
    updateBottomSubmitState(qEl);
    updateSubjectiveSubmitState(qEl);
    updateMultiSubmitState(qEl);
});

// 主观题（问答/简答/计算）：输入区内提交按钮
document.addEventListener('click', function(e){
    const target = e.target;
    if (!target) return;
    const btn = target.closest ? target.closest('.subjective-submit-btn') : null;
    if (!btn) return;
    e.preventDefault();
    checkAnswer(true);
});

// 多选题：提交按钮放在选项下方
document.addEventListener('click', function(e){
    const target = e.target;
    if (!target) return;
    const btn = target.closest ? target.closest('.multi-submit-btn') : null;
    if (!btn) return;
    e.preventDefault();
    if (btn.disabled) {
        showToast('请先选择答案');
        return;
    }
    checkAnswer(true);
});

// 更新答案卡片右侧徽标（答对/答错）
function setAnswerResultBadge(state) {
    // state: true(答对) / false(答错) / 'pending'(待核对) / null(隐藏)
    const host = document.getElementById('answerCard');
    if (!host) return;

    const isCorrect = (state === true);
    const isWrong = (state === false);
    const isPending = (state === 'pending');

    host.classList.toggle('result-correct', isCorrect);
    host.classList.toggle('result-wrong', isWrong);
    host.classList.toggle('result-pending', isPending);

    const badge = host.querySelector('.result-badge');
    if (!badge) return;

    if (isCorrect) {
        badge.textContent = '答对';
        badge.setAttribute('data-state', 'correct');
    } else if (isWrong) {
        badge.textContent = '答错';
        badge.setAttribute('data-state', 'wrong');
    } else if (isPending) {
        badge.textContent = '待核对';
        badge.setAttribute('data-state', 'pending');
    } else {
        badge.textContent = '';
        badge.setAttribute('data-state', '');
    }
}

// 将“当前题”的答案/解析内容渲染到 mainCard 外部的独立卡片容器
function formatFillBlankAnswerForDock(raw, blankCountHint) {
    // raw 格式约定（历史兼容）：
    // - 多空：用 ';;' 分隔每一空
    // - 一空多答案：同一空内用 ';' 分隔备选
    // 示例："1;一;;2;二;;3;三" => 3 空，每空有 2 个备选
    const text = (raw || '').toString().trim();
    if (!text) return '';

    const blanks = text.split(';;').map(s => s.trim()).filter(Boolean);
    const isMultiBlank = blanks.length > 1 || (blankCountHint && blankCountHint > 1);

    // 单空：展示为“可接受答案：A / B / C”
    if (!isMultiBlank) {
        const alts = text.split(';').map(s => s.trim()).filter(Boolean);
        if (alts.length <= 1) {
            return `<div class="blank-ans one"><span class="label">答案</span><span class="val">${escapeHtmlLocal(alts[0] || text)}</span></div>`;
        }
        return `<div class="blank-ans one"><span class="label">可接受答案</span><span class="val">${alts.map(a => `<span class="pill">${escapeHtmlLocal(a)}</span>`).join('')}</span></div>`;
    }

    // 多空：按“空1/空2...”列出，每空内用 pill 展示备选
    const rows = blanks.map((b, i) => {
        const alts = b.split(';').map(s => s.trim()).filter(Boolean);
        const valHtml = (alts.length <= 1)
            ? `<span class="text">${escapeHtmlLocal(alts[0] || '')}</span>`
            : alts.map(a => `<span class="pill">${escapeHtml(a)}</span>`).join('');
        return `<div class="blank-ans-row"><span class="blank-no">空 ${i + 1}</span><span class="blank-val">${valHtml}</span></div>`;
    }).join('');

    return `<div class="blank-ans multi">${rows}</div>`;
}

function escapeHtml(str){
    return (str ?? '').toString()
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
}

function escapeHtmlLocal(str){
    return (str ?? '').toString()
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
}

// 转义HTML并处理换行：将\n转换为<br>标签
function escapeHtmlWithBreaks(str){
    return escapeHtml(str ?? '').replaceAll('\n', '<br>');
}

function updateDockEmptyState(){
    // 仅影响布局：右侧 dock 是否“有内容”
    const mainArea = document.querySelector('.main-area');
    if (!mainArea) return;
    const a = document.getElementById('answerCard');
    const e = document.getElementById('explainCard');
    const ai = document.getElementById('aiExplainCard');
    const aShown = a && a.style.display !== 'none' && a.innerHTML.trim().length > 0;
    const eShown = e && e.style.display !== 'none' && e.innerHTML.trim().length > 0;
    const aiShown = ai && ai.style.display !== 'none' && ai.innerHTML.trim().length > 0;
    mainArea.classList.toggle('dock-empty', !(aShown || eShown || aiShown));
}

function getUserAnswerTextForDisplay(qEl, type){
    try {
        if (!qEl) return '';

        if (type === '选择题' || type === '多选题') {
            const checked = Array.from(qEl.querySelectorAll('input[type="checkbox"]:checked')).map(i => i.value);
            return checked.sort().join('');
        }
        if (type === '判断题') {
            const r = qEl.querySelector('input[type="radio"]:checked');
            return r ? (r.value || '').toString() : '';
        }
        if (type === '填空题') {
            const inputs = Array.from(qEl.querySelectorAll('input[type="text"].main-input, input.main-input[type="text"], input[type="text"].main-input, input[type="text"]'));
            const vals = inputs.map(i => (i.value || '').toString().trim()).filter(v => v.length > 0);
            return vals.join(' / ');
        }
        if (isSubjectiveType(type)) {
            const preferCard = document.body.classList.contains('quiz-layout-card');
            const ta = preferCard ? qEl.querySelector('.question-layout-card textarea') : qEl.querySelector('textarea');
            if (ta) return (ta.value || '').toString().trim();
            const inp = qEl.querySelector('input[type="text"], .main-input');
            return inp ? (inp.value || '').toString().trim() : '';
        }
    } catch (e) {}
    return '';
}

function getInlineAnswerHosts(qEl){
    const answerHost = qEl ? (qEl.querySelector('.answer-inline-host') || document.getElementById('answerCard')) : null;
    const explainHost = qEl ? (qEl.querySelector('.explain-inline-host') || document.getElementById('explainCard')) : null;
    return { answerHost, explainHost };
}

function renderAnswerExplainFromQuestion(qEl, resultState = null) {
    if (!qEl) return;
    const { answerHost, explainHost } = getInlineAnswerHosts(qEl);
    if (!answerHost || !explainHost) return;

    answerHost.innerHTML = '';
    explainHost.innerHTML = '';
    answerHost.style.display = 'none';
    explainHost.style.display = 'none';

    const type = (qEl.getAttribute('data-type') || '').toString();
    const correctRaw = (qEl.getAttribute('data-answer') || '').toString();
    const userAnswerText = getUserAnswerTextForDisplay(qEl, type);

    const blankCountHint = (qEl.querySelectorAll('.blank-item').length) || null;
    const correctAnswerHtml = (type === '填空题')
        ? (formatFillBlankAnswerForDock(correctRaw, blankCountHint) || escapeHtmlWithBreaks(correctRaw))
        : escapeHtmlWithBreaks(correctRaw);

    const isSubjective = isSubjectiveType(type);
    const judgable = isJudgableType(type) && !isSubjective;
    const showAiBtn = (mode !== 'exam');

    let state = resultState;
    if (state === null && judgable) {
        try { state = judgeQuestion(qEl, type, correctRaw); } catch(e) { state = null; }
    }
    if (state === null && isSubjective && mode !== 'memo') {
        state = (mode === 'exam' && EXAM_SUBMITTED) ? 'pending' : 'submitted';
    }

    if (mode === 'memo') {
        const tip = (type === '选择题' || type === '多选题' || type === '判断题')
            ? '已在选项中高亮正确答案'
            : '请对照答案巩固记忆';
        answerHost.innerHTML = `
            <div class="answer-display-card">
              <div class="answer-card-toprow">
                <div class="answer-title">正确答案：${escapeHtmlWithBreaks(correctRaw)}</div>
                ${showAiBtn ? `<button type="button" class="answer-ai-btn" aria-label="AI解析" title="AI解析" onclick="toggleAIExplain()">AI</button>` : ``}
              </div>
              <div class="answer-divider"></div>
              <div class="answer-tip">${tip}</div>
            </div>
        `;
        answerHost.style.display = 'block';
    } else {
        let headerClass = 'submitted';
        let icon = '✓';
        let headerText = '已提交';
        if (state === 'pending') {
            headerClass = 'submitted';
            icon = '✓';
            headerText = '待核对';
        } else if (judgable) {
            const isCorrect = (state === true);
            headerClass = isCorrect ? 'correct' : 'wrong';
            icon = isCorrect ? '✓' : '✕';
            headerText = isCorrect ? '回答正确' : '回答错误';
        }

        const showUserAnswer = (!judgable) || (state === false) || (state === 'pending');
        answerHost.innerHTML = `
            <div class="answer-result-card">
              <div class="answer-card-toprow">
                <div class="result-header ${headerClass}">
                  <span class="result-icon">${icon}</span>
                  <span class="result-text">${headerText}</span>
                </div>
                ${showAiBtn ? `<button type="button" class="answer-ai-btn" aria-label="AI解析" title="AI解析" onclick="toggleAIExplain()">AI</button>` : ``}
              </div>
              <div class="correct-answer">
                <span class="answer-label">正确答案：</span>
                <div class="answer-value">${correctAnswerHtml}</div>
              </div>
              ${showUserAnswer ? `
              <div class="user-answer">
                <span class="answer-label">你的答案：</span>
                <div class="answer-value wrong">${escapeHtmlWithBreaks(userAnswerText || '')}</div>
              </div>` : ``}
            </div>
        `;
        answerHost.style.display = 'block';
    }

    try { syncAnswerAiButtonState(); } catch(e) {}

    const explainSpan = qEl.querySelector('.quiz-card.card-explain .answer');
    const explainRaw = explainSpan ? (explainSpan.textContent || explainSpan.innerText || '') : '';
    if (explainRaw && explainRaw.toString().trim()) {
        explainHost.innerHTML = `
            <div class="explanation-card">
              <div class="explanation-title">解析</div>
              <div class="explanation-text">${escapeHtmlWithBreaks(explainRaw)}</div>
            </div>
        `;
        explainHost.style.display = 'block';
    }
}

function hideAnswerExplainDock(qEl = null) {
    const list = qEl ? [qEl] : Array.from(document.querySelectorAll('.question-box'));
    list.forEach(q => {
        const a = q.querySelector('.answer-inline-host');
        const e = q.querySelector('.explain-inline-host');
        const ai = q.querySelector('.ai-inline-host');
        if (a) { a.style.display = 'none'; a.innerHTML = ''; }
        if (e) { e.style.display = 'none'; e.innerHTML = ''; }
        if (ai) { ai.style.display = 'none'; ai.innerHTML = ''; }
    });

    // 兼容旧 dock（即使已在 CSS 中隐藏）
    const answerHost = document.getElementById('answerCard');
    const explainHost = document.getElementById('explainCard');
    const aiHost = document.getElementById('aiExplainCard');
    if (answerHost) { answerHost.style.display = 'none'; answerHost.innerHTML = ''; answerHost.classList.remove('show'); }
    if (explainHost) { explainHost.style.display = 'none'; explainHost.innerHTML = ''; explainHost.classList.remove('show'); }
    if (aiHost) { aiHost.style.display = 'none'; aiHost.innerHTML = ''; aiHost.classList.remove('show'); }
    try { aiExplainState.open = false; } catch(e) {}
    try { syncAnswerAiButtonState(); } catch(e) {}
    setAnswerResultBadge(null);
    updateDockEmptyState();
}

async function checkAnswer(isManualClick) {
    if (mode === 'exam') return;

    const currentQ = questions[currentIndex];
    const type = currentQ.getAttribute('data-type');
    const answer = currentQ.getAttribute('data-answer');
    const qId = currentQ.getAttribute('data-id');
    
    if (!hasAnswered(currentQ, type)) {
        if (isManualClick) showToast("请先作答！");
        return;
    }

    // 对齐小程序：主观题不自动判对错，只记录“已提交”（不写错题本/做题对错）
    const isSubjective = isSubjectiveType(type);
    const isJudgable = isJudgableType(type) && !isSubjective;
    let isCorrect = null;
    if (isJudgable) {
        isCorrect = judgeQuestion(currentQ, type, answer);
    }
    
    // 登录用户：在显示答案前先检查刷题限制
    if (LOGGED_IN && isJudgable) {
        try {
            const recordUrl = IS_USER_BANK
                ? `${getUserBankApiPrefix()}/quiz/record`
                : '/api/record_result';
            const payload = IS_USER_BANK ? {
                question_id: qId,
                user_answer: getUserAnswerTextForDisplay(currentQ, type),
                is_correct: isCorrect
            } : {
                question_id: qId,
                is_correct: isCorrect,
                clear_mistake_on_correct: getClearMistakeOnCorrectForRequest()
            };

            const res = await fetch(recordUrl, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(payload)
            });
            const data = await res.json();
            const ok = data && (data.status === 'success' || data.code === 0);

            if (!ok) {
                // 处理刷题限制错误（公共题库）
                if (data && data.code === 'QUIZ_LIMIT_REACHED') {
                    showToast(data.message || '已达到刷题限制');
                    // 达到限制，不显示答案，直接返回
                    return;
                }
                showToast((data && data.message) || '保存失败');
                // 其他错误也阻止显示答案
                return;
            }
            // 成功：继续显示答案
        } catch (error) {
            console.error('保存答题记录失败:', error);
            showToast('网络错误，请重试');
            // 网络错误也阻止显示答案
            return;
        }
    }

    // 渲染答案/解析（小程序风格：题目下方/右侧区域）
    renderAnswerExplainFromQuestion(currentQ);
    
    const btnNext = document.getElementById('btn-next');
    if (btnNext) btnNext.style.display = 'block';
    
    // 显示反馈
    if (isJudgable) {
        styleFeedback(currentQ, type, answer, isCorrect);
    } else {
        // 主观题：侧边栏用“已提交”样式（不判对错）
        const idx = currentQ.getAttribute('data-index');
        const li = document.getElementById(`list-item-${idx}`);
        if (li) {
            li.classList.remove('done-correct', 'done-wrong');
            li.classList.add('answered');
        }
    }
    
    disableInputs(currentQ);
    updateBottomSubmitState(currentQ);
    updateSubjectiveSubmitState(currentQ);
    updateMultiSubmitState(currentQ);
    if (!LOGGED_IN && isJudgable) {
        // 未登录不写入错题本，只在本地保留效果
        showToast('未登录：错题不会保存到服务器');
    }

    saveState(true); // 答题后立即同步到服务器

    // ===== 答对自动下一题（悬浮球 ✓✓） =====
    // 仅在刷题/背题等非考试模式生效（本函数开头已拦截 exam）。
    // 触发时机：判题并渲染反馈完成之后。
    try {
        if (isJudgable && isCorrect === true && isFabAutoNextEnabled()) {
            // 最后一题不自动切，避免闪动
            if (currentIndex < totalQuestions - 1) {
                // 给用户一个很短的反馈停留时间
                setTimeout(() => {
                    // 若用户在等待期间已手动切题/改变索引，则不强行覆盖
                    if (questions[currentIndex] === currentQ) {
                        nextQuestion();
                    }
                }, 350);
            }
        }
    } catch (e) {}
}

function finishQuiz() {
    let correctCount = 0;
    let gridHtml = '';
    
    listItems.forEach((item, index) => {
        const isRight = item.classList.contains('done-correct');
        const isWrong = item.classList.contains('done-wrong');
        
        if (isRight) correctCount++;
        
        if (isRight) {
            gridHtml += `<div class="score-item s-correct" onclick="reviewJump(${index})">${index+1}</div>`;
        } else if (isWrong) {
            gridHtml += `<div class="score-item s-wrong" onclick="reviewJump(${index})">${index+1}</div>`;
        } else {
            gridHtml += `<div class="score-item" onclick="reviewJump(${index})">${index+1}</div>`;
        }
    });

    document.getElementById('scoreTitle').innerText = "刷题报告";
    document.getElementById('finalLabel').innerText = "准确率";
    document.getElementById('finalScore').innerText = Math.round((correctCount / totalQuestions) * 100) + "%";
    document.getElementById('scoreDetail').innerText = `答对 ${correctCount} / ${totalQuestions} 题`;
    document.getElementById('scoreGrid').innerHTML = gridHtml;
    document.getElementById('scoreOverlay').style.display = 'flex';
    
    document.getElementById('scoreCircle').style.borderColor = '#007bff';
    document.getElementById('scoreCircle').style.color = '#007bff';
}

function submitExam(force = false) {
    // 服务端提交考试答案（若存在 exam_id）
    try { sendExamAnswers(); } catch(e) {}
    if (isSubmitted) return; // 【修复】如果已交卷，直接阻断

    if (!force) {
        let unAnsweredIndices = [];
        questions.forEach((q, i) => {
            const type = q.getAttribute('data-type');
            if (!hasAnswered(q, type)) {
                unAnsweredIndices.push(i + 1);
            }
        });

        if (unAnsweredIndices.length > 0) {
            alert(`还有 ${unAnsweredIndices.length} 道题未作答！\n题号：${unAnsweredIndices.join(', ')}`);
            if (!isWholeView) showQuestion(unAnsweredIndices[0] - 1);
            return;
        }
        
        if (!confirm("确定要交卷吗？交卷后将显示成绩。")) return;
    }

    // 【修复】立即更新状态并隐藏所有交卷按钮
    isSubmitted = true;
    const mainSubmitBtn = document.getElementById('btn-submit-exam');
    const tempSubmitBtn = document.getElementById('temp-submit');
    if(mainSubmitBtn) mainSubmitBtn.style.display = 'none';
    if(tempSubmitBtn) tempSubmitBtn.remove();
    
    clearInterval(timerInterval);
    let totalScore = 0;
    let correctCount = 0;
    let gridHtml = '';

    questions.forEach((q, index) => {
        const type = q.getAttribute('data-type');
        const answer = q.getAttribute('data-answer');
        const scoreVal = parseFloat(q.getAttribute('data-score'));
        
        const isCorrect = judgeQuestion(q, type, answer);
        styleFeedback(q, type, answer, isCorrect);
        // 考试交卷后：不在题内展开解析，答案/解析在回顾跳题时渲染到独立卡片
        disableInputs(q);

        if (isCorrect) {
            totalScore += scoreVal;
            correctCount++;
            gridHtml += `<div class="score-item s-correct" onclick='reviewJump(${index})'>${index+1}</div>`;
        } else {
            gridHtml += `<div class="score-item s-wrong" onclick='reviewJump(${index})'>${index+1}</div>`;
        }
    });

    document.getElementById('finalScore').innerText = totalScore;
    document.getElementById('scoreDetail').innerText = `答对 ${correctCount} / ${totalQuestions} 题`;
    document.getElementById('scoreGrid').innerHTML = gridHtml;
    document.getElementById('scoreOverlay').style.display = 'flex';
}

function reviewExam() {
    document.getElementById('scoreOverlay').style.display = 'none';
    
    // 考试模式下，回顾时不再显示交卷按钮，确保只能下一题查看
    if (mode === 'exam') {
        const btnSubmit = document.getElementById('btn-submit-exam');
        if(btnSubmit) btnSubmit.style.display = 'none';
        
        const btnNext = document.getElementById('btn-next-exam');
        if(btnNext) btnNext.style.display = 'block';
    }
    
    if (!isWholeView) {
        currentIndex = 0;
        showQuestion(0);
    }
    
    const tempSubmit = document.getElementById('temp-submit');
    if(tempSubmit) tempSubmit.remove();
}

function reviewJump(index) {
    reviewExam();
    if (isWholeView) {
        jumpTo(index); 
    } else {
        showQuestion(index);
    }
}

function judgeQuestion(q, type, answer) {
    if (type === '选择题' || type === '判断题' || type === '多选题') {
        // 兼容两种布局：传统布局和卡片布局
        const inputs = q.querySelectorAll('input[type="checkbox"], input[type="radio"]');
        let userVals = [];
        inputs.forEach(i => { if(i.checked) userVals.push(i.value) });
        
        // 多选题：漏选、少选也要判错，必须完全匹配
        if (type === '多选题') {
            // 确保 answer 是字符串
            const correctAnswer = String(answer || '');
            // 用户答案排序
            const userAnswerStr = userVals.sort().join("");
            // 标准答案排序
            const correctAnswerStr = correctAnswer.split('').sort().join("");
            // 必须数量相等且内容完全匹配
            return userVals.length === correctAnswer.length && userAnswerStr === correctAnswerStr;
        }
        
        // 选择题和判断题：保持原有逻辑
        return userVals.sort().join("") === answer;
    } else if (type === '填空题') {
        // 兼容两种布局
        const inputs = q.querySelectorAll('.main-input[type="text"], input.main-input');
        const correctBlanks = answer.split(';;').map(a => a.trim());

        if (inputs.length === 0) return false; // 没有找到输入框

        let allCorrect = true;
        for (let i = 0; i < inputs.length; i++) {
            const userInput = inputs[i].value.trim();
            const correctAnswersForBlank = (correctBlanks[i] || '').split(';').map(a => a.trim());
            if (!correctAnswersForBlank.includes(userInput)) {
                allCorrect = false;
                break;
            }
        }
        return allCorrect;
    } else if (isSubjectiveType(type)) {
        const textarea = q.querySelector('textarea');
        if (textarea) return !!(textarea.value && textarea.value.trim());
        const inp = q.querySelector('input[type="text"], .main-input');
        return !!(inp && (inp.value || '').trim());
    }
    return false;
}

function hasAnswered(q, type) {
    if (type === '选择题' || type === '判断题' || type === '多选题') {
        // 兼容两种布局：传统布局和卡片布局
        return !!q.querySelector('input[type="checkbox"]:checked, input[type="radio"]:checked');
    }

    if (type === '填空题') {
        // 兼容两种布局
        const inputs = q.querySelectorAll('.main-input[type="text"], input.main-input[type="text"], input[type="text"].main-input');
        if (inputs.length > 1) {
            return Array.from(inputs).every(i => (i.value || '').trim().length > 0);
        }
        // 单空：优先找填空题的 text input（避免误选到隐藏/其它类型的 input）
        const one = q.querySelector('input.main-input[type="text"], input[type="text"].main-input, input[type="text"]');
        return !!(one && (one.value || '').trim());
    }

    if (isSubjectiveType(type)) {
        const preferCard = document.body.classList.contains('quiz-layout-card');
        const ta = preferCard ? q.querySelector('.question-layout-card textarea') : q.querySelector('textarea');
        if (ta) return !!(ta.value && ta.value.trim());
        const inp = q.querySelector('input[type="text"], .main-input');
        return !!(inp && (inp.value || '').trim());
    }
    return false;
}

function styleFeedback(q, type, answer, isCorrect) {
    if (type === '选择题' || type === '判断题' || type === '多选题') {
        q.querySelectorAll('input').forEach(input => {
            const label = input.parentElement;
            const optionCard = label.closest('.option-card');
            const isCardLayout = !!optionCard;
            
            // 移除所有标记
            if (!isCardLayout) {
                // 传统布局：在 label 上添加标记
                label.classList.remove('correct-opt', 'wrong-opt');
            }
            if (optionCard) {
                // 卡片布局：在卡片上添加标记
                optionCard.classList.remove('correct-opt', 'wrong-opt');
            }
            
            if (isCorrect) {
                // 做对时，用户选中的都绿色
                if (input.checked) {
                    if (!isCardLayout) {
                        label.classList.add('correct-opt');
                    }
                    if (optionCard) optionCard.classList.add('correct-opt');
                }
            } else {
                // 做错时，用户选中的错误选项标红
                if (input.checked && !answer.includes(input.value)) {
                    if (!isCardLayout) {
                        label.classList.add('wrong-opt');
                    }
                    if (optionCard) optionCard.classList.add('wrong-opt');
                }
                // 总是高亮正确答案
                if (answer.includes(input.value)) {
                    if (!isCardLayout) {
                        label.classList.add('correct-opt');
                    }
                    if (optionCard) optionCard.classList.add('correct-opt');
                }
            }
        });
    } else if (type === '填空题') {
        const inputs = q.querySelectorAll('.main-input');
        const correctBlanks = answer.split(';;').map(a => a.trim());

        inputs.forEach((input, i) => {
            input.classList.remove('input-correct', 'input-wrong');
            const userInput = input.value.trim();
            const correctAnswersForBlank = (correctBlanks[i] || '').split(';').map(a => a.trim());
            
            if (correctAnswersForBlank.includes(userInput)) {
                input.classList.add('input-correct');
            } else {
                input.classList.add('input-wrong');
            }
        });
    }
    // 刷题模式下，题目列表高亮（仅可判题型：选择/多选/判断/填空）
    if (mode !== 'exam' && isJudgableType(type) && !isSubjectiveType(type)) {
        const idx = q.getAttribute('data-index');
        const item = document.getElementById(`list-item-${idx}`);
        if (item) {
            item.classList.remove('done-correct', 'done-wrong', 'answered');
            if (isCorrect) {
                item.classList.add('done-correct');
            } else {
                item.classList.add('done-wrong');
            }
        }
    }
}

// 防抖定时器
let saveStateTimer = null;
let lastSavedPayload = null;
let syncPending = false; // 标记是否有待同步的数据

// 保留做题痕迹样式 - 带防抖机制
function saveState(immediate = false) {
    let statusMap = {};
    let answerMap = {};
    listItems.forEach((item, index) => {
        if (item.classList.contains('done-correct')) statusMap[index] = 'correct';
        if (item.classList.contains('done-wrong')) statusMap[index] = 'wrong';
        // 保存用户选项/答案
        const q = document.getElementById(`q-${index}`);
        if (q) {
            const type = q.getAttribute('data-type');
            if (type === '选择题' || type === '判断题' || type === '多选题') {
                const checked = Array.from(q.querySelectorAll('input:checked')).map(i => i.value);
                answerMap[index] = checked;
            } else if (type === '填空题') {
                const inputs = q.querySelectorAll('.main-input');
                answerMap[index] = Array.from(inputs).map(input => input.value);

            } else if (isSubjectiveType(type)) {
                const preferCard = document.body.classList.contains('quiz-layout-card');
                const ta = preferCard ? q.querySelector('.question-layout-card textarea') : q.querySelector('textarea');
                if (ta) answerMap[index] = ta.value;
                else {
                    const inp = q.querySelector('input[type="text"], .main-input');
                    answerMap[index] = inp ? inp.value : '';
                }
            }
        }
    });
    const payload = { index: currentIndex, status: statusMap, answers: answerMap, timestamp: Date.now() };
    // 保留题目顺序，防止覆盖服务端保存的打乱顺序
    if (cachedOrder) {
        payload.order = cachedOrder;
    }

    // 立即保存到本地存储
    localStorage.setItem(progressKey(), JSON.stringify(payload));
    lastSavedPayload = payload;
    syncPending = true;

    // 登录用户同步到服务器
    if (LOGGED_IN) {
        if (immediate) {
            // 立即同步（答题后等重要操作）
            if (saveStateTimer) clearTimeout(saveStateTimer);
            syncToServer(payload);
        } else {
            // 防抖保存（200ms内多次调用只执行最后一次）
            if (saveStateTimer) clearTimeout(saveStateTimer);
            saveStateTimer = setTimeout(() => {
                syncToServer(payload);
            }, 200);
        }
    }
}

// 同步到服务器
async function syncToServer(payload) {
    if (!LOGGED_IN) return;
    try {
        const key = progressKey();
        const res = await fetch('/api/progress', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ key: key, data: payload })
        });
        if (res.ok) {
            syncPending = false;
        } else {
            console.error('[进度同步] 服务器错误:', res.status);
        }
    } catch(e) {
        console.error('[进度同步] 失败:', e);
    }
}

// 页面卸载时强制同步
window.addEventListener('beforeunload', function(e) {
    if (LOGGED_IN && syncPending && lastSavedPayload) {
        try {
            const key = progressKey();
            const data = JSON.stringify({ key: key, data: lastSavedPayload });
            // 使用 sendBeacon 确保数据发送
            if (navigator.sendBeacon) {
                const blob = new Blob([data], {type: 'application/json'});
                navigator.sendBeacon('/api/progress', blob);
            }
        } catch(err) {
            console.error('[进度同步] beforeunload 发送失败:', err);
        }
    }
});

// 页面隐藏时也尝试同步（切换标签页等）
document.addEventListener('visibilitychange', function() {
    if (document.visibilityState === 'hidden' && LOGGED_IN && syncPending && lastSavedPayload) {
        syncToServer(lastSavedPayload);
    }
});

function refreshAnsweredMarkersFromInputs(){
    // 用当前输入内容重建“已答”标记（考试模式侧边栏）
    try {
        questions.forEach((q, idx) => {
            const it = document.getElementById(`list-item-${idx}`);
            if (!it) return;
            const type = q.getAttribute('data-type');
            if (hasAnswered(q, type)) it.classList.add('answered');
            else it.classList.remove('answered');
        });
    } catch(e) {}
}

function loadState() {
    try {
        const data = JSON.parse(localStorage.getItem(progressKey()));
        if (data) {
            // 缓存题目顺序，保存时需要保留
            if (data.order && Array.isArray(data.order)) {
                cachedOrder = data.order;
            }
            if (data.status) {
                for (const [idx, status] of Object.entries(data.status)) {
                    const item = document.getElementById(`list-item-${idx}`);
                    if (item) {
                        if (status === 'correct') item.classList.add('done-correct');
                        if (status === 'wrong') item.classList.add('done-wrong');
                    }
                    const q = document.getElementById(`q-${idx}`);
                    if (q && (status === 'correct' || status === 'wrong')) {
                        const type = q.getAttribute('data-type');
                        const answer = q.getAttribute('data-answer');
                        const isCorrect = status === 'correct';

                        // 1. 恢复用户的选择 (必须在 styleFeedback 之前)
                        if (data.answers && data.answers[idx]) {
                            const userAnswer = data.answers[idx];
                            if ((type === '选择题' || type === '判断题' || type === '多选题') && Array.isArray(userAnswer)) {
                                q.querySelectorAll('input').forEach(i => { i.checked = userAnswer.includes(i.value); });
                            } else if (type === '填空题') {
                                // 填空题：这里保存的是数组（每空一个值），需要逐个恢复
                                if (Array.isArray(userAnswer)) {
                                    const inputs = q.querySelectorAll('.main-input');
                                    inputs.forEach((input, i) => {
                                        if (typeof userAnswer[i] !== 'undefined') input.value = userAnswer[i] || '';
                                    });
                                } else {
                                    const inp = q.querySelector('input[type="text"], .main-input');
                                    if (inp) inp.value = userAnswer;
                                }
                            } else if (isSubjectiveType(type)) {
                                const ta = q.querySelector('textarea');
                                if (ta) ta.value = userAnswer;
                                else {
                                    const inp = q.querySelector('input[type="text"], .main-input');
                                    if (inp) inp.value = userAnswer;
                                }
                            }
                        }

                        // 2. 恢复高亮效果
                        styleFeedback(q, type, answer, isCorrect);

                        // 3. 已作答题：需要能在回顾时展示“答案/解析”
                        // 注意：此处只是恢复状态，具体显示在 showQuestion / checkAnswer 时渲染到独立卡片
                        disableInputs(q);
                    }
                }
            }
            if (data.answers) {
                for (const [idx, val] of Object.entries(data.answers)) {
                    const q = document.getElementById(`q-${idx}`);
                    if (q) {
                        const type = q.getAttribute('data-type');
                        if ((type === '选择题' || type === '判断题' || type === '多选题') && Array.isArray(val)) {
                            q.querySelectorAll('input').forEach(i => { i.checked = val.includes(i.value); });
                        } else if (type === '填空题' && Array.isArray(val)) {
                            const inputs = q.querySelectorAll('.main-input');
                            inputs.forEach((input, i) => {
                                if (val[i]) {
                                    input.value = val[i];
                                }
                            });
                        } else if (isSubjectiveType(type)) {
                            const ta = q.querySelector('textarea');
                            if (ta) ta.value = val;
                            else {
                                const inp = q.querySelector('input[type="text"], .main-input');
                                if (inp) inp.value = val;
                            }
                        }
                    }
                }
            }
            if (data.index) currentIndex = data.index;
        }

        // 考试模式也需要根据恢复的输入来重建“已答”标记
        if (mode === 'exam') {
            refreshAnsweredMarkersFromInputs();
        }
    } catch(e) {}
}

function resetQuizUI(){
    // 清空列表状态
    document.querySelectorAll('.q-item').forEach(item=>{
        item.classList.remove('done-correct','done-wrong','answered');
    });
    // 清空题目状态
    questions.forEach((q)=>{
        q.classList.remove('checked-mode');
        // 取消选中和禁用
        q.querySelectorAll('input, textarea').forEach(el=>{
            el.disabled=false;
            if(el.type==='checkbox' || el.type==='radio') el.checked=false;
            else el.value='';
        });
        // 去掉高亮
        q.querySelectorAll('.correct-opt, .wrong-opt, .input-correct, .input-wrong').forEach(el=>{
            el.classList.remove('correct-opt','wrong-opt','input-correct','input-wrong');
        });
        // 清理独立答案/解析卡片
        hideAnswerExplainDock();
    });

    currentIndex=0;
    showQuestion(0);
    try {
        updateBottomSubmitState(questions[0]);
        updateSubjectiveSubmitState(questions[0]);
        updateMultiSubmitState(questions[0]);
    } catch(e) {}
}

async function clearProgress(confirmMsg = "确定要清除当前模式的做题进度吗？") {
    if(confirm(confirmMsg)) {
        localStorage.removeItem(progressKey());
        if (LOGGED_IN) {
            try { await fetch(`/api/progress?key=${encodeURIComponent(progressKey())}`, { method: 'DELETE' }); } catch(e) {}
        }
        resetQuizUI(); // Reset the UI to its initial state
        showToast('进度已清除');
        return true; // Indicates data was cleared
    }
    return false; // User cancelled
}

async function reshuffle() {
    const confirmed = confirm("重新打乱将清空当前进度，确定要继续吗？");
    if (confirmed) {
        // 1. Clear progress data without reloading
        localStorage.removeItem(progressKey());
        if (LOGGED_IN) {
            try { await fetch(`/api/progress?key=${encodeURIComponent(progressKey())}`, { method: 'DELETE' }); } catch(e) {}
        }

        // 2. Get all question elements
        const mainCard = document.getElementById('mainCard');
        const questionBoxes = Array.from(mainCard.querySelectorAll('.question-box'));
        const sidebarList = document.getElementById('question-list');
        const listItemsElements = Array.from(sidebarList.querySelectorAll('.q-item'));

        // 3. Create a mapping from original DOM index to elements
        const questionMap = {};
        questionBoxes.forEach((box, i) => {
            questionMap[i] = { box: box, item: listItemsElements[i] };
        });

        // 4. Shuffle the indices
        let indices = Object.keys(questionMap).map(Number);
        for (let i = indices.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [indices[i], indices[j]] = [indices[j], indices[i]];
        }

        // 5. Re-append elements in the new order and update attributes
        const footer = mainCard.querySelector('.footer');
        questionBoxes.forEach(box => box.remove());
        listItemsElements.forEach(item => item.remove());

        indices.forEach((originalIndex, newIndex) => {
            const pair = questionMap[originalIndex];
            const box = pair.box;
            const item = pair.item;

            // Update question box
            box.id = `q-${newIndex}`;
            box.dataset.index = newIndex;
            mainCard.insertBefore(box, footer);

            // Update list item
            item.id = `list-item-${newIndex}`;
            item.querySelector('span:first-child').textContent = newIndex + 1;
            item.setAttribute('onclick', `jumpTo(${newIndex})`);
            sidebarList.appendChild(item);
        });

        // 6. Reset UI state - 重新获取 DOM 元素（注意：这里直接赋值给模块级变量，不是 window 属性）
        questions = document.querySelectorAll('.question-box');
        listItems = document.querySelectorAll('.q-item');
        
        questions.forEach((q, index) => {
            q.classList.remove('checked-mode');
            q.querySelectorAll('input, textarea').forEach(el => {
                el.disabled = false;
                if (el.type === 'checkbox' || el.type === 'radio') el.checked = false;
                else el.value = '';
            });
            q.querySelectorAll('.correct-opt, .wrong-opt, .input-correct, .input-wrong').forEach(el => {
                el.classList.remove('correct-opt', 'wrong-opt', 'input-correct', 'input-wrong');
            });
            // 独立答案/解析卡片由 showQuestion/checkAnswer 控制，这里只需清理 dock
            hideAnswerExplainDock();
        });
        listItems.forEach(item => {
            item.classList.remove('done-correct', 'done-wrong', 'answered');
        });

        // 7. 收集新的题目顺序并更新 cachedOrder，然后同步到服务器
        const newOrder = Array.from(questions).map(q => parseInt(q.getAttribute('data-id')));
        cachedOrder = newOrder;
        
        // 8. Show the first question
        currentIndex = 0;
        showQuestion(0);
        
        // 9. 立即保存新顺序到服务器（重要：必须在 showQuestion 之后，因为 showQuestion 也会调用 saveState）
        saveState(true);
        
        showToast('题目已重新排序');
    }
}

function showToast(msg) {
    const t = document.getElementById('toast');
    t.innerText = msg;
    t.style.display = 'block';
    setTimeout(() => t.style.display = 'none', 2000);
}

function toggleSidebar() {
    document.getElementById('sidebar').classList.toggle('open');
    document.getElementById('overlay').classList.toggle('show');
}

function toggleTheme() {
    document.body.classList.toggle('dark-mode');
    localStorage.setItem('theme', document.body.classList.contains('dark-mode') ? 'dark' : 'light');
}

// ===== 设置弹窗（替代悬浮球菜单） =====
function openFeatureModal(){
    const ov = document.getElementById('featureOverlay');
    if (!ov) return;
    ov.style.display = 'flex';
    try {
        const sw = document.getElementById('featureAutoNextSwitch');
        if (sw) sw.checked = isFabAutoNextEnabled();
    } catch(e) {}
}

function closeFeatureModal(e){
    if (e) {
        // 点击遮罩关闭
        if (e.target && e.target.id !== 'featureOverlay') return;
    }
    const ov = document.getElementById('featureOverlay');
    if (ov) ov.style.display = 'none';
}

function onFeatureAutoNextToggle(checked){
    try {
        setFabAutoNextEnabled(!!checked);
        showToast(checked ? '已开启：答对自动切题' : '已关闭：答对自动切题');
    } catch(e) {}
}

function clearCurrentQuestionProgress(){
    const q = questions[currentIndex];
    if (!q) { showToast('未找到当前题目'); return false; }

    const type = q.getAttribute('data-type') || '';

    // 考试回顾（已交卷）禁用
    if (mode === 'exam' && EXAM_SUBMITTED) {
        showToast('回顾模式：无法清除本题');
        return false;
    }
    // 考试进行中：也不允许清除（避免影响考试作答流程）
    if (mode === 'exam' && isSubmitted) {
        showToast('考试中：无法清除本题');
        return false;
    }

    // 1) 清除输入
    try {
        if (type === '选择题' || type === '判断题' || type === '多选题') {
            q.querySelectorAll('input[type="checkbox"], input[type="radio"]').forEach(inp => {
                inp.checked = false;
                const lab = inp.closest('label');
                if (lab) lab.classList.remove('selected');
                const card = inp.closest('.option-card');
                if (card) card.classList.remove('selected');
            });
        } else if (type === '填空题') {
            q.querySelectorAll('.main-input').forEach(inp => {
                inp.value = '';
                inp.classList.remove('input-correct', 'input-wrong');
            });
        } else if (isSubjectiveType(type)) {
            const ta = q.querySelector('.question-layout-card textarea, textarea');
            if (ta) ta.value = '';
            q.querySelectorAll('input[type="text"], .main-input').forEach(inp => { inp.value = ''; });
        }
    } catch(e) {}

    // 2) 恢复可编辑状态（若之前已判题/禁用）
    try {
        q.classList.remove('checked-mode');
        q.querySelectorAll('input, textarea').forEach(el => {
            el.disabled = false;
        });
        // 移除选项/输入高亮
        q.querySelectorAll('.correct-opt, .wrong-opt, .input-correct, .input-wrong').forEach(el => {
            el.classList.remove('correct-opt', 'wrong-opt', 'input-correct', 'input-wrong');
        });
    } catch(e) {}

    // 3) 清除侧边栏该题状态
    try {
        const idx = q.getAttribute('data-index');
        const li = document.getElementById(`list-item-${idx !== null ? idx : currentIndex}`);
        if (li) li.classList.remove('done-correct', 'done-wrong', 'answered');
    } catch(e) {}

    // 4) 清掉答案/解析/AI
    try { hideAnswerExplainDock(q); } catch(e) {}

    // 5) 恢复按钮状态
    try {
        if (mode !== 'exam') {
            const btnNext = document.getElementById('btn-next');
            if (btnNext) btnNext.style.display = 'block';
            updateBottomSubmitState(q);
            updateSubjectiveSubmitState(q);
            updateMultiSubmitState(q);
        }
    } catch(e) {}

    // 6) 保存进度（会写本地/登录则同步）
    try {
        if (mode !== 'exam' || (mode === 'exam' && !isSubmitted)) {
            saveState(true);
        }
    } catch(e) {}

    // 7) 重新计算“已答”标记（考试模式侧边栏）
    try {
        if (mode === 'exam') markAnswered(currentIndex);
    } catch(e) {}

    showToast('已清除本题进度');
    return true;
}

function toggleStar(btn, id) {
     const url = IS_USER_BANK
        ? `${getUserBankApiPrefix()}/questions/${encodeURIComponent(id)}/favorite`
        : '/api/favorite';

     const options = IS_USER_BANK ? { method: 'POST' } : {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ question_id: id })
     };

     fetch(url, options).then(res => res.json()).then(data => {
        const ok = data && (data.status === 'success' || data.code === 0);
        if(ok) {
            const isActive = btn.classList.toggle('active');
            const icon = btn.querySelector ? btn.querySelector('.q-action-icon') : null;
            if (icon) icon.textContent = isActive ? '♥' : '♡';
        }
     });
}

function applyReviewFromServer() {
    try {
        const uaMap = USER_ANSWERS || {};
        questions.forEach(q => {
            const qid = parseInt(q.getAttribute('data-id'));
            const type = q.getAttribute('data-type');
            const stdAns = q.getAttribute('data-answer');
            const ua = uaMap[qid] || '';
            // 填充用户答案
            if (type === '选择题' || type === '多选题') {
                const chosen = new Set((ua || '').split(''));
                q.querySelectorAll('input[type="checkbox"]').forEach(i => { i.checked = chosen.has(i.value); });
            } else if (type === '判断题') {
                q.querySelectorAll('input[type="radio"]').forEach(i => { i.checked = (i.value === ua); });
            } else if (type === '填空题') {
                // ua 可能是单空字符串，也可能是多空 JSON 数组字符串
                let uaList = null;
                try {
                    const tmp = JSON.parse(ua);
                    if (Array.isArray(tmp)) uaList = tmp;
                } catch(e) { uaList = null; }
                const inputs = q.querySelectorAll('input[type="text"]');
                if (inputs && inputs.length > 1 && uaList) {
                    inputs.forEach((input, i) => { if (typeof uaList[i] !== 'undefined') input.value = uaList[i] || ''; });
                } else {
                    const inp = q.querySelector('input[type="text"]'); if (inp) inp.value = ua;
                }
            } else {
                const preferCard = document.body.classList.contains('quiz-layout-card');
                const ta = preferCard ? q.querySelector('.question-layout-card textarea') : q.querySelector('textarea');
                if (ta) ta.value = ua;
            }
            // 展示解析与高亮
            const isCorrect = (function(){
                if (type === '选择题') return (ua.split('').sort().join('') === (stdAns||'').split('').sort().join('')) && ua !== '';
                if (type === '多选题') {
                    // 多选题：漏选、少选也要判错，必须完全匹配
                    if (!ua || ua === '') return false;
                    const correctAnswer = String(stdAns || '');
                    const userAnswerArr = ua.split('').sort();
                    const correctAnswerArr = correctAnswer.split('').sort();
                    // 必须数量相等且内容完全匹配
                    return userAnswerArr.length === correctAnswerArr.length && 
                           userAnswerArr.join('') === correctAnswerArr.join('');
                }
                if (type === '判断题') return ua === stdAns && ua !== '';
                if (type === '填空题') {
                    // 标准答案：不同空用 ";;" 分隔；每空多答案用 ";" 分隔
                    // 例：北京;北平;;上海;沪
                    const std = (stdAns||'').trim();
                    const stdBlanks = std ? std.split(';;').map(s=>s.trim()) : [''];

                    // 用户答案：多空用 JSON 数组字符串提交，否则为单空字符串
                    let uaList = null;
                    try {
                        const tmp = JSON.parse(ua);
                        if (Array.isArray(tmp)) uaList = tmp.map(x => (x||'').toString().trim());
                    } catch(e) { uaList = null; }

                    function matchOne(userOne, stdOne){
                        const u = (userOne||'').toString().trim();
                        if(!u) return false;
                        const cands = (stdOne||'').split(';').map(x=>x.trim()).filter(Boolean);
                        const arr = cands.length ? cands : [(stdOne||'').trim()];
                        return arr.some(x=>x===u);
                    }

                    if (uaList) {
                        if (uaList.length !== stdBlanks.length) return false;
                        return stdBlanks.every((s, i) => matchOne(uaList[i], s));
                    }

                    // 单空
                    if (stdBlanks.length > 1) return false;
                    return matchOne(ua, stdBlanks[0]);
                }
                return !!ua;
            })();
            styleFeedback(q, type, stdAns, isCorrect);
            // 回顾模式下，答案/解析在 showQuestion 时渲染到独立卡片
            disableInputs(q);
        });
        // 初始化进度条
        const plabel = document.getElementById('progress-label');
        if (plabel) plabel.innerText = `1 / ${questions.length}`;
        const pf = document.getElementById('progress-fill');
        if (pf) pf.style.width = (questions.length? (1/questions.length*100):0)+'%';
    } catch(e) {}
}

function collectExamAnswers() {
    const arr = [];
    questions.forEach(q => {
        const qid = parseInt(q.getAttribute('data-id'));
        const type = q.getAttribute('data-type');
        let ua = '';
        if (type === '选择题') {
            ua = Array.from(q.querySelectorAll('input[type="checkbox"]:checked')).map(i=>i.value).join('');
        } else if (type === '判断题') {
            const r = q.querySelector('input[type="radio"]:checked');
            ua = r ? r.value : '';
        } else if (type === '填空题') {
            const inputs = q.querySelectorAll('input[type="text"]');
            if (inputs && inputs.length > 1) {
                ua = JSON.stringify(Array.from(inputs).map(x => (x.value || '').trim()));
            } else {
                const i = q.querySelector('input[type="text"]');
                ua = i ? (i.value || '') : '';
            }
        } else {
            const t = q.querySelector('textarea');
            ua = t ? (t.value || '') : '';
        }
        arr.push({ question_id: qid, user_answer: ua });
    });
    return arr;
}
async function sendExamAnswers() {
    if (!EXAM_ID) return;
    try {
        const answers = collectExamAnswers();
        const res = await fetch('/api/exams/submit', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ exam_id: EXAM_ID, answers }) });
        const js = await res.json();
        if (res.ok && js.status === 'success') {
            // 以服务端结果为准更新分数与统计
            if (typeof js.total_score !== 'undefined') {
                const fs = document.getElementById('finalScore');
                if (fs) fs.innerText = js.total_score;
            }
            if (typeof js.total !== 'undefined' && typeof js.correct !== 'undefined') {
                const sd = document.getElementById('scoreDetail');
                if (sd) sd.innerText = `答对 ${js.correct} / ${js.total} 题`;
            }
        }
    } catch(e) { /* 忽略网络错误 */ }
}

function applyDraftFromServer(){
    try {
        const uaMap = USER_ANSWERS || {};
        questions.forEach(q => {
            const qid = parseInt(q.getAttribute('data-id'));
            const type = q.getAttribute('data-type');
            const ua = uaMap[qid] || '';
            if (!ua) return;

            // 若本地/页面上已经有输入，则不覆盖（避免 loadState 后被服务端草稿冲掉）
            if (type === '选择题') {
                const existed = Array.from(q.querySelectorAll('input[type="checkbox"]')).some(i => i.checked);
                if (existed) return;
                const chosen = new Set((ua || '').split(''));
                q.querySelectorAll('input[type="checkbox"]').forEach(i => { i.checked = chosen.has(i.value); });
            } else if (type === '判断题') {
                const existed = !!q.querySelector('input[type="radio"]:checked');
                if (existed) return;
                q.querySelectorAll('input[type="radio"]').forEach(i => { i.checked = (i.value === ua); });
            } else if (type === '填空题') {
                const inputs = q.querySelectorAll('input[type="text"].main-input, input[type="text"]');
                const existed = Array.from(inputs).some(i => (i.value || '').trim().length > 0);
                if (existed) return;

                // ua 可能是单空字符串，也可能是多空 JSON 数组字符串
                let uaList = null;
                try {
                    const tmp = JSON.parse(ua);
                    if (Array.isArray(tmp)) uaList = tmp;
                } catch(e) { uaList = null; }

                if (inputs.length > 1 && uaList) {
                    inputs.forEach((input, i) => { if (typeof uaList[i] !== 'undefined') input.value = uaList[i] || ''; });
                } else {
                    const inp = q.querySelector('input[type="text"].main-input, input[type="text"]');
                    if (inp) inp.value = ua;
                }
            } else {
                const ta = q.querySelector('textarea');
                const existed = !!(ta && (ta.value || '').trim().length > 0);
                if (existed) return;
                if (ta) ta.value = ua;
            }
        });

        // 补齐完草稿后，刷新一次“已答”标记（考试侧边栏）
        try {
            questions.forEach((q, idx) => { if (hasAnswered(q, q.getAttribute('data-type'))) { const it=document.getElementById(`list-item-${idx}`); if(it) it.classList.add('answered'); } });
        } catch(e) {}
    } catch(e) {}
}
let autoSaveTimer = null;
function scheduleAutoSave(){
    if (!EXAM_ID) return;
    try {
        window.addEventListener('beforeunload', function(){
            try {
                const payload = JSON.stringify({ exam_id: EXAM_ID, answers: collectExamAnswers() });
                if (navigator.sendBeacon) {
                    const blob = new Blob([payload], {type: 'application/json'});
                    navigator.sendBeacon('/api/exams/save_draft', blob);
                }
            } catch(e){}
        });
    } catch(e){}
    autoSaveTimer = setInterval(async ()=>{
        try {
            const answers = collectExamAnswers();
            await fetch('/api/exams/save_draft', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ exam_id: EXAM_ID, answers }) });
        } catch(e) {}
    }, 5000);
}

// Mobile swipe gesture for next/prev question（仅用于切题；页面横向滚动已在 CSS 中禁用）
const __mainCardSwipeHost = document.getElementById('mainCard');
if (__mainCardSwipeHost) {
    let touchStartX = 0;
    let touchStartY = 0;

    __mainCardSwipeHost.addEventListener('touchstart', e => {
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
    }, { passive: true });

    __mainCardSwipeHost.addEventListener('touchend', e => {
        const touchEndX = e.changedTouches[0].screenX;
        const touchEndY = e.changedTouches[0].screenY;
        handleSwipe(touchStartX, touchStartY, touchEndX, touchEndY);
    }, { passive: true });
}

function handleSwipe(startX, startY, endX, endY) {
    const diffX = endX - startX;
    const diffY = endY - startY;

    // Only trigger if horizontal swipe is significant and vertical swipe is not
    if (Math.abs(diffX) > 100 && Math.abs(diffY) < 100) {
        if (diffX < 0) {
            // Swiped left
            nextQuestion();
        } else {
            // Swiped right
            prevQuestion();
        }
    }
}

init();

function getQuizHotkeys(){
    const DEFAULT_QUIZ_HOTKEYS = {
        prev_question: 'ArrowLeft',
        next_question: 'ArrowRight',
        toggle_favorite: 'KeyF',
        choose_option_1: 'Digit1',
        choose_option_2: 'Digit2',
        choose_option_3: 'Digit3',
        choose_option_4: 'Digit4',
        blank_prev: 'ArrowUp',
        blank_next: 'ArrowDown',
        submit_or_next: 'Enter'
    };
    try {
        const js = JSON.parse(localStorage.getItem('quiz_hotkeys_v1') || 'null');
        if (!js || typeof js !== 'object') return { ...DEFAULT_QUIZ_HOTKEYS };
        
        // 合并用户设置，但保留空字符串（表示用户清空了该快捷键，应该禁用）
        const result = { ...DEFAULT_QUIZ_HOTKEYS };
        for (const key in js) {
            if (key in DEFAULT_QUIZ_HOTKEYS) {
                // 如果用户设置的值是空字符串，保留空字符串（禁用该快捷键）
                // 如果用户设置了有效值，使用用户的值
                // 如果用户没有设置（undefined），使用默认值
                if (js[key] !== undefined) {
                    result[key] = js[key];
                }
            }
        }
        return result;
    } catch(e) {
        return { ...DEFAULT_QUIZ_HOTKEYS };
    }
}

function normalizeEventToken(e){
    const mods = [];
    if (e.ctrlKey) mods.push('Ctrl');
    if (e.altKey) mods.push('Alt');
    if (e.shiftKey) mods.push('Shift');
    if (e.metaKey) mods.push('Meta');

    const code = e.code || '';
    const isModifierOnly = ['ShiftLeft','ShiftRight','ControlLeft','ControlRight','AltLeft','AltRight','MetaLeft','MetaRight'].includes(code);
    if (isModifierOnly) return '';

    const keyCode = (code === 'Space') ? ' ' : (code || e.key || '');
    if (!keyCode) return '';
    return mods.length ? `${mods.join('+')}+${keyCode}` : keyCode;
}

function isElementVisibleForHotkey(el) {
    if (!el) return false;
    const style = window.getComputedStyle(el);
    if (style.display === 'none' || style.visibility === 'hidden') return false;
    return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
}

function getActiveOptionLabelsForHotkey(currentQ) {
    const preferCard = document.body.classList.contains('quiz-layout-card');
    const card = Array.from(currentQ.querySelectorAll('.question-layout-card .options-container label'));
    const traditional = Array.from(currentQ.querySelectorAll('.question-layout-traditional .options label'));
    const primary = preferCard ? card : traditional;
    const secondary = preferCard ? traditional : card;
    const hasVisible = (arr) => arr && arr.some(isElementVisibleForHotkey);
    if (primary.length && hasVisible(primary)) return primary;
    if (secondary.length && hasVisible(secondary)) return secondary;
    return primary.length ? primary : secondary;
}

function getActiveFavBtnForHotkey(currentQ) {
    const preferCard = document.body.classList.contains('quiz-layout-card');
    const card = currentQ.querySelector('.question-layout-card .fav-btn');
    const traditional = currentQ.querySelector('.question-layout-traditional .fav-btn');
    const primary = preferCard ? card : traditional;
    const secondary = preferCard ? traditional : card;
    if (primary && isElementVisibleForHotkey(primary)) return primary;
    if (secondary && isElementVisibleForHotkey(secondary)) return secondary;
    return primary || secondary;
}

document.addEventListener('keydown', function(e) {
    const isInputFocused = document.activeElement.tagName === 'INPUT';
    const isTextareaFocused = document.activeElement.tagName === 'TEXTAREA';

    // 如果成绩弹窗显示，则禁用所有快捷键
    if (document.getElementById('scoreOverlay').style.display === 'flex') {
        return;
    }

    const HK = getQuizHotkeys();
    const token = normalizeEventToken(e);

    // 提交/查看结果/下一题（可自定义，默认 Enter）
    // 空字符串表示用户清空了该快捷键，应该禁用
    const hasCustomSubmit = HK.submit_or_next && HK.submit_or_next.trim() !== '';
    if ((hasCustomSubmit && token === HK.submit_or_next) || (!hasCustomSubmit && e.key === 'Enter')) {
        // 当焦点在问答题的文本域时，允许默认的换行行为
        if (isTextareaFocused) {
            return;
        }
        // 阻止其他所有 Enter 的默认行为（比如表单提交）
        e.preventDefault();

        // 考试模式：优先“下一题”
        const btnNextExam = document.getElementById('btn-next-exam');
        if (btnNextExam && btnNextExam.style.display !== 'none' && !btnNextExam.disabled) {
            btnNextExam.click();
            return;
        }
        
        // 刷题模式：若“提交答案”可见，则优先提交（对齐小程序：有提交按钮时先提交，再下一题）
        const { btnCheck, wrapper } = getBottomSubmitElements();
        if (btnCheck && wrapper && wrapper.style.display !== 'none') {
            if (btnCheck.disabled) {
                showToast('请先作答！');
                return;
            }
            btnCheck.click();
            return;
        }

        // 多选题：选项下方提交按钮
        try {
            const currentQ = questions[currentIndex];
            const multiBtn = currentQ ? currentQ.querySelector('.multi-submit-btn') : null;
            if (multiBtn && isElementVisibleForHotkey(multiBtn)) {
                if (multiBtn.disabled) {
                    showToast('请先选择答案');
                    return;
                }
                multiBtn.click();
                return;
            }
        } catch(e) {}

        // 默认：下一题
        const btnNext = document.getElementById('btn-next');
        if (btnNext && btnNext.style.display !== 'none' && !btnNext.disabled) {
            btnNext.click();
            return;
        }
        return; // Enter 键逻辑处理完毕
    }

    // 填空题中，使用自定义快捷键切换输入框（当 input 聚焦时）
    // 只检查自定义快捷键，如果设置了自定义快捷键就不再检查默认值
    // 空字符串表示用户清空了该快捷键，应该禁用
    if (isInputFocused) {
        let isPrev = false;
        let isNext = false;
        
        const hasCustomBlankPrev = HK.blank_prev && HK.blank_prev.trim() !== '';
        const hasCustomBlankNext = HK.blank_next && HK.blank_next.trim() !== '';
        
        if (hasCustomBlankPrev && token === HK.blank_prev) {
            isPrev = true;
        } else if (!hasCustomBlankPrev && e.key === 'ArrowUp') {
            isPrev = true;
        }
        
        if (hasCustomBlankNext && token === HK.blank_next) {
            isNext = true;
        } else if (!hasCustomBlankNext && e.key === 'ArrowDown') {
            isNext = true;
        }
        
        if (isPrev || isNext) {
            const arrowKey = isNext ? 'ArrowDown' : 'ArrowUp';
            const currentQ = questions[currentIndex];
            if (currentQ && currentQ.dataset.type === '填空题') {
                const inputs = Array.from(currentQ.querySelectorAll('.main-input'));
                if (inputs.length > 1) {
                    const focusedIndex = inputs.indexOf(document.activeElement);
                    if (focusedIndex !== -1) {
                        e.preventDefault(); // 阻止光标移动到行首/行尾
                        let nextIndex;
                        if (arrowKey === 'ArrowDown') {
                            nextIndex = (focusedIndex + 1) % inputs.length;
                        } else { // ArrowUp
                            nextIndex = (focusedIndex - 1 + inputs.length) % inputs.length;
                        }
                        inputs[nextIndex].focus();
                        return; // 功能已处理，退出
                    }
                }
            }
        }
    }

    // 如果焦点在任何输入框或文本域中，则不触发以下的快捷键
    if (isInputFocused || isTextareaFocused) {
        return;
    }

    const currentQ = questions[currentIndex];
    if (!currentQ) return;
    const options = getActiveOptionLabelsForHotkey(currentQ);

    // 选项选择（选择题/判断题）
    // 只使用自定义快捷键，如果设置了自定义快捷键就不再使用默认值
    // 空字符串表示用户清空了该快捷键，应该禁用
    const chooseMap = {};
    const hasCustomOption1 = HK.choose_option_1 && HK.choose_option_1.trim() !== '';
    const hasCustomOption2 = HK.choose_option_2 && HK.choose_option_2.trim() !== '';
    const hasCustomOption3 = HK.choose_option_3 && HK.choose_option_3.trim() !== '';
    const hasCustomOption4 = HK.choose_option_4 && HK.choose_option_4.trim() !== '';
    
    if (hasCustomOption1) chooseMap[HK.choose_option_1] = 0;
    if (hasCustomOption2) chooseMap[HK.choose_option_2] = 1;
    if (hasCustomOption3) chooseMap[HK.choose_option_3] = 2;
    if (hasCustomOption4) chooseMap[HK.choose_option_4] = 3;
    
    // 如果用户没有自定义任何选项快捷键，则使用默认值
    if (Object.keys(chooseMap).length === 0) {
        chooseMap['Digit1'] = 0;
        chooseMap['Digit2'] = 1;
        chooseMap['Digit3'] = 2;
        chooseMap['Digit4'] = 3;
    }
    
    if (token in chooseMap) {
        e.preventDefault();
        const optionIndex = chooseMap[token];
        if (options[optionIndex]) {
            const optInp = options[optionIndex].querySelector('input');
            if (optInp) optInp.click();
        }
        return;
    }

    // 上/下一题
    // 只检查自定义快捷键，如果设置了自定义快捷键就不再检查默认值
    // 空字符串表示用户清空了该快捷键，应该禁用
    const hasCustomPrev = HK.prev_question && HK.prev_question.trim() !== '';
    const hasCustomNext = HK.next_question && HK.next_question.trim() !== '';
    
    if (hasCustomPrev && token === HK.prev_question) {
        e.preventDefault();
        prevQuestion();
        return;
    }
    if (!hasCustomPrev && e.key === 'ArrowLeft') {
        e.preventDefault();
        prevQuestion();
        return;
    }
    
    if (hasCustomNext && token === HK.next_question) {
        e.preventDefault();
        nextQuestion();
        return;
    }
    if (!hasCustomNext && e.key === 'ArrowRight') {
        e.preventDefault();
        nextQuestion();
        return;
    }

    // 收藏
    // 只检查自定义快捷键，如果设置了自定义快捷键就不再检查默认值
    // 空字符串表示用户清空了该快捷键，应该禁用
    const hasCustomFavorite = HK.toggle_favorite && HK.toggle_favorite.trim() !== '';
    
    if (hasCustomFavorite && token === HK.toggle_favorite) {
        e.preventDefault();
        const favBtn = getActiveFavBtnForHotkey(currentQ);
        if (favBtn) favBtn.click();
        return;
    }
    if (!hasCustomFavorite && (e.key === 'f' || e.key === 'F')) {
        e.preventDefault();
        const favBtn = getActiveFavBtnForHotkey(currentQ);
        if (favBtn) favBtn.click();
        return;
    }
});

function nextQuestion() {
    if (typeof currentIndex === 'undefined') currentIndex = 0;
    if (currentIndex < totalQuestions - 1) {
        showQuestion(currentIndex + 1);
    }
}
function prevQuestion() {
    if (typeof currentIndex === 'undefined') currentIndex = 0;
    if (currentIndex > 0) {
        showQuestion(currentIndex - 1);
    }
}

function setupImageGallery(questionElement) {
    const gallery = questionElement.querySelector('.question-image-gallery');
    if (!gallery) return;

    let images = [];
    try {
        const imageData = gallery.dataset.images;
        // Compatibility for both JSON string and plain string
        if (imageData.startsWith('[')) {
            images = JSON.parse(imageData);
        } else if (imageData) {
            images = [imageData];
        }
    } catch (e) {
        console.error('Failed to parse image data:', e);
        images = [];
    }

    if (images.length === 0) {
        gallery.style.display = 'none';
        return;
    }

    gallery.style.display = 'block';
    const imageWrapper = gallery.querySelector('.gallery-main-image-wrapper');
    const controls = gallery.querySelector('.gallery-controls');
    const counter = gallery.querySelector('.gallery-counter');
    const prevBtn = gallery.querySelector('.gallery-prev');
    const nextBtn = gallery.querySelector('.gallery-next');

    let currentImageIndex = 0;

    function showImage(index) {
        imageWrapper.innerHTML = `<img src="{{ url_for('main.main_pages.serve_upload', filename='') }}${images[index]}" alt="题目图片 ${index + 1}" style="max-width: 100%; max-height: 400px; border-radius: 12px; border: 1px solid var(--border-color);">`;
        if (images.length > 1) {
            counter.textContent = `${index + 1} / ${images.length}`;
        }
    }

    if (images.length > 1) {
        controls.style.display = 'flex';
        prevBtn.onclick = () => {
            currentImageIndex = (currentImageIndex - 1 + images.length) % images.length;
            showImage(currentImageIndex);
        };
        nextBtn.onclick = () => {
            currentImageIndex = (currentImageIndex + 1) % images.length;
            showImage(currentImageIndex);
        };
    } else {
        controls.style.display = 'none';
    }

    showImage(0);
}

function gotoPage(p){
    const url = new URL(window.location.href);
    url.searchParams.set('page', p);
    const szSel = document.getElementById('pageSize');
    if (szSel) url.searchParams.set('size', szSel.value);
    window.location.href = url.toString();
}
function changeSize(sz){
    const url = new URL(window.location.href);
    url.searchParams.set('size', sz);
    url.searchParams.set('page', 1);
    window.location.href = url.toString();
}

// ===== 提示框优先级管理系统 =====
const HINT_PRIORITY_QUEUE = [
    {
        id: 'fabHint',
        storageKey: FAB_HINT_DISMISSED_KEY,
        showFunc: 'showFabHint',
        priority: 1, // 优先级：数字越小越优先
        delay: 800 // 显示延迟（ms）
    },
    {
        id: 'shortcutHint',
        storageKey: 'shortcut_hint_dismissed',
        showFunc: 'showShortcutHint',
        priority: 2,
        delay: 800
    }
];

// 当前显示的提示框ID
let currentHintId = null;

// 本次会话中临时关闭的提示（刷新页面后重置）
const temporarilyDismissedHints = new Set();

// 检查并显示下一个提示
function showNextHint() {
    // 如果当前有提示正在显示，不处理
    if (currentHintId) {
        return;
    }
    
    // 按优先级排序
    const sortedHints = [...HINT_PRIORITY_QUEUE].sort((a, b) => a.priority - b.priority);
    
    // 查找第一个未被永久关闭且未被临时关闭的提示
    for (const hint of sortedHints) {
        const permanentlyDismissed = localStorage.getItem(hint.storageKey) === '1';
        const temporarilyDismissed = temporarilyDismissedHints.has(hint.id);
        
        if (!permanentlyDismissed && !temporarilyDismissed) {
            currentHintId = hint.id;
            
            // 延迟显示，确保页面加载完成
            setTimeout(() => {
                const showFunc = window[hint.showFunc];
                if (typeof showFunc === 'function') {
                    showFunc();
                }
            }, hint.delay);
            return;
        }
    }
}

// 关闭当前提示并尝试显示下一个
function closeCurrentHintAndShowNext() {
    currentHintId = null;
    
    // 延迟显示下一个提示，避免视觉跳动
    setTimeout(() => {
        showNextHint();
    }, 500);
}

// ===== 悬浮球功能提示横幅 =====
function showFabHint() {
    // 卡片布局已移除悬浮球：直接跳过该提示
    if (document.body.classList.contains('quiz-layout-card')) {
        closeCurrentHintAndShowNext();
        return;
    }
    // 检查用户是否选择了"不再提示"
    const dismissed = localStorage.getItem(FAB_HINT_DISMISSED_KEY);
    if (dismissed === '1') {
        closeCurrentHintAndShowNext(); // 尝试显示下一个
        return;
    }
    
    // 确保 DOM 已加载，重试机制
    function tryShowHint(retries) {
        retries = retries || 0;
        const hint = document.getElementById('fabHint');
        if (!hint) {
            // 如果元素还不存在，最多重试10次（1秒）
            if (retries < 10) {
                setTimeout(() => tryShowHint(retries + 1), 100);
            } else {
                closeCurrentHintAndShowNext(); // 元素不存在，尝试显示下一个
            }
            return;
        }
        
        // 显示提示
        hint.style.display = 'flex';
        hint.style.opacity = '0.9'; // 确保初始透明度正确
        
        // 5秒后自动淡出（但不关闭，用户仍可手动关闭）
        setTimeout(() => {
            if (hint && hint.style.display !== 'none') {
                hint.style.opacity = '0.5';
            }
        }, 5000);
    }
    
    tryShowHint();
}

// 关闭本次提示（不保存状态，下次仍会显示）
function dismissFabHint() {
    const hint = document.getElementById('fabHint');
    if (hint) {
        hint.style.display = 'none';
        hint.style.opacity = '0';
    }
    // 临时关闭：标记为本次会话已关闭，清除当前提示ID，然后显示下一个
    if (currentHintId === 'fabHint') {
        temporarilyDismissedHints.add('fabHint');
        currentHintId = null;
        // 延迟显示下一个提示，避免视觉跳动
        setTimeout(() => {
            showNextHint();
        }, 500);
    }
}

// 不再提示（保存状态，下次不再显示）
function dismissFabHintPermanently() {
    const hint = document.getElementById('fabHint');
    if (hint) {
        hint.style.display = 'none';
        hint.style.opacity = '0';
        localStorage.setItem(FAB_HINT_DISMISSED_KEY, '1');
    }
    // 永久关闭：触发队列显示下一个提示
    closeCurrentHintAndShowNext();
}

// 试试看：打开悬浮球菜单
function tryFabHint() {
    const fab = document.getElementById('quizFab');
    const menu = document.getElementById('quizFabMenu');
    
    if (!fab || !menu) {
        return;
    }
    
    // 用户主动试用，说明已知悉功能，永久关闭提示（不会在下次访问时再显示）
    dismissFabHintPermanently();
    
    // 延迟300ms打开悬浮球，让用户注意到过渡
    setTimeout(() => {
        // 如果悬浮球未打开，则打开它
        if (!fabOpen) {
            toggleFab(true);
            
            // 3秒后自动关闭（给用户足够时间查看菜单项）
            setTimeout(() => {
                if (fabOpen) {
                    toggleFab(false);
                    showToast('提示：再次点击悬浮球可打开菜单');
                }
            }, 3000);
        }
    }, 300);
}

// 全局函数，供HTML onclick调用
window.dismissFabHint = dismissFabHint;
window.dismissFabHintPermanently = dismissFabHintPermanently;
window.tryFabHint = tryFabHint;

// ===== 快捷键提示横幅 =====
const SHORTCUT_HINT_DISMISSED_KEY = 'shortcut_hint_dismissed';

function showShortcutHint() {
    // 检查用户是否选择了"不再提示"
    const dismissed = localStorage.getItem(SHORTCUT_HINT_DISMISSED_KEY);
    if (dismissed === '1') {
        closeCurrentHintAndShowNext(); // 尝试显示下一个
        return;
    }
    
    const hint = document.getElementById('shortcutHint');
    if (!hint) {
        closeCurrentHintAndShowNext(); // 元素不存在，尝试显示下一个
        return;
    }
    
    // 显示提示
    hint.style.display = 'flex';
    hint.style.opacity = '1';
    
    // 5秒后自动淡出（但不关闭，用户仍可手动关闭）
    setTimeout(() => {
        if (hint && hint.style.display !== 'none') {
            hint.style.opacity = '0.5';
        }
    }, 5000);
}

// 关闭本次提示（不保存状态，下次仍会显示）
function dismissShortcutHint() {
    const hint = document.getElementById('shortcutHint');
    if (hint) {
        hint.style.display = 'none';
        hint.style.opacity = '0';
    }
    // 临时关闭：标记为本次会话已关闭，清除当前提示ID，然后显示下一个
    if (currentHintId === 'shortcutHint') {
        temporarilyDismissedHints.add('shortcutHint');
        currentHintId = null;
        // 延迟显示下一个提示，避免视觉跳动
        setTimeout(() => {
            showNextHint();
        }, 500);
    }
}

// 不再提示（保存状态，下次不再显示）
function dismissShortcutHintPermanently() {
    const hint = document.getElementById('shortcutHint');
    if (hint) {
        hint.style.display = 'none';
        hint.style.opacity = '0';
        localStorage.setItem(SHORTCUT_HINT_DISMISSED_KEY, '1');
    }
    // 永久关闭：触发队列显示下一个提示
    closeCurrentHintAndShowNext();
}

// 跳转到快捷键设置页
function goToShortcutSettings() {
    // 用户主动去设置，说明已知悉快捷键功能，永久关闭提示
    dismissShortcutHintPermanently();
    window.location.href = '/settings/hotkeys#hotkeys-config';
}

// 全局函数，供HTML onclick调用
window.dismissShortcutHint = dismissShortcutHint;
window.dismissShortcutHintPermanently = dismissShortcutHintPermanently;
window.goToShortcutSettings = goToShortcutSettings;

// 调试用：手动测试显示提示（可在控制台调用 testHints()）
window.testHints = function() {
    console.log('[测试] 清除所有提示状态');
    localStorage.removeItem(FAB_HINT_DISMISSED_KEY);
    localStorage.removeItem(SHORTCUT_HINT_DISMISSED_KEY);
    currentHintId = null;
    // 隐藏所有提示
    const fabHint = document.getElementById('fabHint');
    const shortcutHint = document.getElementById('shortcutHint');
    if (fabHint) {
        fabHint.style.display = 'none';
        fabHint.style.opacity = '0';
    }
    if (shortcutHint) {
        shortcutHint.style.display = 'none';
        shortcutHint.style.opacity = '0';
    }
    // 重新开始显示队列
    setTimeout(() => showNextHint(), 500);
};

// 旧的测试函数保持兼容
window.testFabHint = function() {
    console.log('[测试] 使用新的测试函数 testHints() 来测试完整流程');
    window.testHints();
};
