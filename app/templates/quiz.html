<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    {% set is_fav_scope = (source == 'favorites' or mode == 'favorites') %}
    {% set is_mis_scope = (source == 'mistakes' or mode == 'mistakes') %}
    {% if mode == 'exam' %}
        <title>æ¨¡æ‹Ÿè€ƒè¯•</title>
    {% elif mode == 'memo' %}
        <title>{{ 'æ”¶è—æœ¬èƒŒé¢˜' if is_fav_scope else ('é”™é¢˜æœ¬èƒŒé¢˜' if is_mis_scope else 'èƒŒé¢˜æ¨¡å¼') }}</title>
    {% else %}
        <title>{{ 'æ”¶è—æœ¬' if is_fav_scope else ('é”™é¢˜æœ¬' if is_mis_scope else 'åˆ·é¢˜') }}</title>
    {% endif %}
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 128 128'%3E%3Crect width='128' height='128' rx='24' fill='%23007bff'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='central' text-anchor='middle' font-size='88' fill='white'%3E%F0%9F%93%98%3C/text%3E%3C/svg%3E">
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 128 128'%3E%3Crect width='128' height='128' rx='24' fill='%23007bff'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='central' text-anchor='middle' font-size='88' fill='white'%3E%F0%9F%93%98%3C/text%3E%3C/svg%3E">
    <meta name="theme-color" content="#007bff">
    <style>
        :root {
            --bg-color: #fafafa;
            --card-bg: rgba(255, 255, 255, 0.75);
            --card-bg-solid: rgba(255, 255, 255, 0.95);
            --text-color: #1d1d1f;
            --text-sub: #86868b;
            --border-color: rgba(0, 0, 0, 0.08);
            --primary: #007AFF;
            --primary-light: rgba(0, 122, 255, 0.12);
            --success: #34c759;
            --danger: #ff3b30;
            --warning: #ff9500;
            --blur: blur(60px) saturate(200%);
            --shadow: 0 2px 16px rgba(0, 0, 0, 0.06), 0 1px 2px rgba(0, 0, 0, 0.04);
            --shadow-hover: 0 4px 24px rgba(0, 0, 0, 0.08), 0 2px 4px rgba(0, 0, 0, 0.06);
            --hover-bg: rgba(142, 142, 147, 0.08);
            --active-bg: var(--primary);
            --active-text: #ffffff;
        }

        body.dark-mode {
            --bg-color: #000000;
            --card-bg: rgba(28, 28, 30, 0.6);
            --card-bg-solid: rgba(28, 28, 30, 0.95);
            --text-color: #f5f5f7;
            --text-sub: #a1a1a6;
            --border-color: rgba(255, 255, 255, 0.12);
            --primary: #0a84ff;
            --primary-light: rgba(10, 132, 255, 0.2);
            --shadow: 0 2px 16px rgba(0, 0, 0, 0.5), 0 1px 2px rgba(0, 0, 0, 0.4);
            --shadow-hover: 0 4px 24px rgba(0, 0, 0, 0.6), 0 2px 4px rgba(0, 0, 0, 0.5);
            --hover-bg: rgba(142, 142, 147, 0.12);
        }
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', Arial, sans-serif;
            background: transparent;
            color: var(--text-color);
            min-height: 100vh;
            transition: color 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            -webkit-tap-highlight-color: transparent;
            -webkit-text-size-adjust: 100%;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            position: relative;
        }
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.4'/%3E%3C/svg%3E");
            pointer-events: none;
            z-index: 0;
            opacity: 0.02;
            mix-blend-mode: overlay;
        }
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #ffffff 0%, #fafafa 30%, #f5f5f7 70%, #f0f0f2 100%);
            z-index: -1;
            pointer-events: none;
        }
        body.dark-mode::after {
            background: linear-gradient(180deg, #1c1c1e 0%, #000000 40%, #000000 100%);
        }
        .app-container { display: flex; min-height: 100vh; position: relative; }

        /* ä¾§è¾¹æ æ ·å¼ */
        .sidebar { 
            width: 280px; 
            background: var(--card-bg);
            backdrop-filter: var(--blur);
            -webkit-backdrop-filter: var(--blur);
            border-right: 0.5px solid var(--border-color); 
            display: flex; 
            flex-direction: column; 
            position: absolute; 
            left: -280px; 
            top: 0; 
            bottom: 0; 
            transition: left 0.4s cubic-bezier(0.4, 0, 0.2, 1); 
            z-index: 1000; 
            box-shadow: var(--shadow-hover);
        }
        .sidebar.open { left: 0; }
        .overlay { 
            position: fixed; 
            top: 0; 
            left: 0; 
            right: 0; 
            bottom: 0; 
            background: rgba(0,0,0,0.4); 
            z-index: 999; 
            display: none; 
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        .overlay.show { display: block; }
        .sidebar-header { 
            padding: 20px; 
            border-bottom: 0.5px solid var(--border-color); 
            background: transparent;
            display: flex; 
            flex-direction: column; 
            gap: 12px;
        }
        .sidebar-title-row { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            font-weight: 600;
            font-size: 18px;
            letter-spacing: -0.3px;
        }
        .sidebar-content { flex: 1; overflow-y: auto; padding: 12px; }
        
        .q-item { 
            padding: 12px 16px; 
            margin-bottom: 4px; 
            border-radius: 12px; 
            cursor: pointer; 
            font-size: 15px; 
            color: var(--text-sub); 
            display: flex; 
            align-items: center; 
            justify-content: space-between;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .q-item:hover { 
            background-color: var(--hover-bg);
            transform: translateX(2px);
        }
        .q-item.active { 
            background-color: rgba(0, 122, 255, 0.1);
            color: var(--primary);
            font-weight: 600;
            border-left: 3px solid var(--primary);
        }
        body.dark-mode .q-item.active {
            background-color: rgba(10, 132, 255, 0.15);
            color: var(--primary);
            border-left-color: var(--primary);
        }
        .q-item.done-correct { 
            color: var(--success); 
            background-color: rgba(52, 199, 89, 0.2); 
        }
        .q-item.done-wrong { 
            color: var(--danger); 
            background-color: rgba(255, 59, 48, 0.2); 
        }
        .q-item.answered { 
            border-left: 3px solid #af52de; 
            background-color: rgba(175, 82, 222, 0.1); 
            color: #af52de; 
            font-weight: 600; 
        }

        /* ä¸»åŒºåŸŸ - ç¡®ä¿è¿™é‡Œå¯ä»¥æ»šåŠ¨ */
        .main-area { flex: 1; display: flex; flex-direction: column; align-items: center; padding: 20px; overflow-y: auto; -webkit-overflow-scrolling: touch; height: 100vh; box-sizing: border-box; }
        
        /* å¡ç‰‡å®¹å™¨ */
        .card-container { 
            width: 100%; 
            max-width: 700px; 
            background: var(--card-bg);
            backdrop-filter: var(--blur);
            -webkit-backdrop-filter: var(--blur);
            border-radius: 24px; 
            box-shadow: var(--shadow);
            border: 0.5px solid rgba(255, 255, 255, 0.95);
            padding: 32px; 
            min-height: 450px; 
            display: flex; 
            flex-direction: column; 
            position: relative; 
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1); 
            margin-top: 20px; 
            margin-bottom: 20px;
            isolation: isolate;
        }
        .card-container::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 24px;
            padding: 0.5px;
            background: rgba(255, 255, 255, 0.95);
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask-composite: exclude;
            pointer-events: none;
            z-index: 1;
        }
        body.dark-mode .card-container::before {
            background: rgba(255, 255, 255, 0.15);
        }
        .card-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 35%;
            background: linear-gradient(180deg, 
                rgba(255, 255, 255, 0.4) 0%,
                rgba(255, 255, 255, 0.15) 50%,
                transparent 100%
            );
            border-radius: 24px 24px 0 0;
            pointer-events: none;
            z-index: 2;
        }
        body.dark-mode .card-container::after {
            background: linear-gradient(180deg, 
                rgba(255, 255, 255, 0.08) 0%,
                rgba(255, 255, 255, 0.03) 50%,
                transparent 100%
            );
        }
        .card-container > * {
            position: relative;
            z-index: 3;
        }
        
        /* ã€ä¿®å¤ã€‘æ•´å·é¢„è§ˆæ¨¡å¼ - å…³é”®ä¿®å¤æ»šåŠ¨é—®é¢˜ */
        .card-container.whole-view { 
            display: block; 
            height: auto !important; 
            max-height: none !important;
            overflow: visible !important;
            min-height: 80vh; 
        }
        .card-container.whole-view .question-box { display: flex !important; border-bottom: 1px solid var(--border-color); padding-bottom: 30px; margin-bottom: 30px; animation: none; }
        .card-container.whole-view .question-box:last-child { border-bottom: none; }
        /* éšè—æ‰ä¸éœ€è¦çš„åº•éƒ¨æ  */
        .card-container.whole-view .footer { display: none !important; }
        .card-container.whole-view .progress-bar { display: none !important; }
        
        .header { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 24px; 
            border-bottom: 0.5px solid var(--border-color); 
            padding-bottom: 16px; 
            position: relative;
            z-index: 5;
        }
        .btn-menu { 
            border: 0.5px solid var(--border-color); 
            background: rgba(142, 142, 147, 0.1);
            backdrop-filter: blur(40px) saturate(180%);
            -webkit-backdrop-filter: blur(40px) saturate(180%);
            padding: 8px 14px; 
            border-radius: 10px; 
            cursor: pointer; 
            color: var(--text-color); 
            font-size: 15px;
            font-weight: 500;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 1px 2px rgba(0,0,0,0.04);
        }
        .btn-menu:hover {
            background: rgba(142, 142, 147, 0.15);
            border-color: rgba(0,0,0,0.1);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.06);
        }
        body.dark-mode .btn-menu {
            background: rgba(142, 142, 147, 0.12);
            border-color: rgba(255,255,255,0.12);
        }
        body.dark-mode .btn-menu:hover {
            background: rgba(142, 142, 147, 0.18);
            border-color: rgba(255,255,255,0.18);
        }
        
        .mode-badge { 
            padding: 6px 14px; 
            border-radius: 20px; 
            font-size: 13px; 
            font-weight: 600;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 0.5px solid transparent;
        }
        .bg-quiz { 
            background: rgba(0, 122, 255, 0.1);
            color: var(--primary);
            border-color: rgba(0, 122, 255, 0.2);
        }
        body.dark-mode .bg-quiz {
            background: rgba(10, 132, 255, 0.15);
            border-color: rgba(10, 132, 255, 0.3);
        }
        .bg-memo { 
            background: rgba(90, 200, 250, 0.15);
            color: #5ac8fa;
            border-color: rgba(90, 200, 250, 0.3);
        }
        body.dark-mode .bg-memo {
            background: rgba(90, 200, 250, 0.2);
            border-color: rgba(90, 200, 250, 0.4);
        }
        .bg-mistakes { 
            background: rgba(255, 59, 48, 0.1);
            color: var(--danger);
            border-color: rgba(255, 59, 48, 0.2);
        }
        body.dark-mode .bg-mistakes {
            background: rgba(255, 59, 48, 0.15);
            border-color: rgba(255, 59, 48, 0.3);
        }
        .bg-fav { 
            background: rgba(255, 149, 0, 0.1);
            color: var(--warning);
            border-color: rgba(255, 149, 0, 0.2);
        }
        body.dark-mode .bg-fav {
            background: rgba(255, 149, 0, 0.15);
            border-color: rgba(255, 149, 0, 0.3);
        }
        .bg-exam { 
            background: rgba(175, 82, 222, 0.1);
            color: #af52de;
            border-color: rgba(175, 82, 222, 0.2);
        }
        body.dark-mode .bg-exam {
            background: rgba(175, 82, 222, 0.15);
            border-color: rgba(175, 82, 222, 0.3);
        }
        
        .progress-bar { 
            position: relative; 
            width: 100%; 
            height: 18px; 
            background: var(--hover-bg); 
            border-radius: 9px; 
            overflow: hidden; 
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.08);
        }
        .progress-fill { 
            height: 100%; 
            background: var(--primary); 
            width: 0%; 
            opacity: 0.55; 
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1); 
        }
        .exam-mode .progress-fill { background: #af52de; }
        .progress-label { 
            position: absolute; 
            left: 50%; 
            top: 50%; 
            transform: translate(-50%, -50%); 
            font-size: 12px; 
            line-height: 1; 
            color: var(--text-sub); 
            font-weight: 500; 
            pointer-events: none; 
            z-index: 2; 
            letter-spacing: 0.5px;
            text-shadow: 0 1px 1px rgba(255,255,255,0.5);
        }
        body.dark-mode .progress-label {
            color: var(--text-color);
            text-shadow: 0 1px 1px rgba(0,0,0,0.5);
        }
        @media (max-width: 768px) { .progress-bar { height: 16px; border-radius: 8px; } .progress-label { font-size: 12px; } }

        .question-box { 
            display: none; 
            flex: 1; 
            flex-direction: column; 
            position: relative; 
            margin-top: 24px; 
            animation: slideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1); 
        }
        @keyframes slideIn { 
            from { 
                opacity: 0; 
                transform: translateX(12px); 
            } 
            to { 
                opacity: 1; 
                transform: translateX(0); 
            } 
        }
        .question-box.active { display: flex; }
        
        .fav-btn { 
            position: absolute; 
            top: 0; 
            right: 0; 
            font-size: 24px; 
            color: var(--text-sub); 
            cursor: pointer; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
            z-index: 10;
            padding: 8px;
            border-radius: 50%;
        }
        .fav-btn:hover {
            background: var(--hover-bg);
        }
        .fav-btn.active { 
            color: var(--warning); 
            transform: scale(1.1); 
        }
        
        .q-type-label { 
            display: inline-block; 
            background: rgba(0, 122, 255, 0.1);
            color: var(--primary);
            border: 0.5px solid rgba(0, 122, 255, 0.2);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 6px 12px; 
            border-radius: 8px; 
            font-size: 12px; 
            font-weight: 600; 
            margin-bottom: 16px;
            letter-spacing: 0.3px;
        }
        body.dark-mode .q-type-label {
            background: rgba(10, 132, 255, 0.15);
            border-color: rgba(10, 132, 255, 0.3);
            color: var(--primary);
        }
        .q-content { 
            font-size: 20px; 
            font-weight: 600; 
            line-height: 1.6; 
            margin-bottom: 28px; 
            color: var(--text-color); 
            padding-right: 40px;
            letter-spacing: -0.3px;
        }

        .options label { 
            display: block; 
            padding: 14px 18px; 
            margin-bottom: 12px; 
            border: 0.5px solid var(--border-color); 
            border-radius: 12px; 
            cursor: pointer; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
            position: relative; 
            background: rgba(255,255,255,0.5);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
        }
        .options label:hover { 
            background-color: rgba(255,255,255,0.7); 
            border-color: var(--primary);
            transform: translateX(2px);
        }
        body.dark-mode .options label {
            background: rgba(28,28,30,0.5);
            border-color: var(--border-color);
        }
        body.dark-mode .options label:hover {
            background: rgba(28,28,30,0.7);
            border-color: var(--primary);
        }
        .options input { 
            margin-right: 12px; 
            cursor: pointer;
            accent-color: var(--primary);
        }
        .options input:checked + span { 
            font-weight: 600; 
            color: var(--primary); 
        }
        
        .exam-mode .options input:checked + span { color: #af52de; }
        .exam-mode .options input:checked { accent-color: #af52de; }
        
        .options label.correct-opt { 
            border-color: var(--success); 
            background-color: rgba(52, 199, 89, 0.1); 
            color: var(--success); 
            font-weight: 600; 
        }
        .options label.wrong-opt { 
            border-color: var(--danger); 
            background-color: rgba(255, 59, 48, 0.1); 
            color: var(--danger); 
        }
        
        /* ç¦ç”¨æ¨¡å¼ï¼šé˜²æ­¢æŸ¥çœ‹ç­”æ¡ˆåè¯¯è§¦ */
        .checked-mode .options label { cursor: not-allowed; opacity: 0.8; }
        .checked-mode .options label:hover { border-color: var(--opt-border); background: var(--card-bg); }
        .checked-mode .options label.correct-opt { border-color: #28a745 !important; background-color: rgba(40, 167, 69, 0.1) !important; opacity: 1;}
        .checked-mode .options label.wrong-opt { border-color: #dc3545 !important; background-color: rgba(220, 53, 69, 0.1) !important; opacity: 1;}

        .main-input { 
            width: 100%; 
            padding: 14px 18px; 
            border: 0.5px solid var(--border-color); 
            border-radius: 12px; 
            font-size: 17px; 
            background: rgba(255,255,255,0.5);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            color: var(--text-color); 
            box-sizing: border-box;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            -webkit-appearance: none;
        }
        .fill-in-the-blanks {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        .blank-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .blank-item label {
            font-weight: 500;
            color: var(--text-sub);
            white-space: nowrap;
        }
        .main-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px var(--primary-light);
            background: rgba(255,255,255,0.7);
        }
        body.dark-mode .main-input {
            background: rgba(28,28,30,0.5);
            border-color: var(--border-color);
        }
        body.dark-mode .main-input:focus {
            background: rgba(28,28,30,0.7);
            border-color: var(--primary);
        }
        .input-correct { 
            border-color: var(--success) !important; 
            background-color: rgba(52, 199, 89, 0.05); 
            color: var(--success); 
        }
        .input-wrong { 
            border-color: var(--danger) !important; 
            background-color: rgba(255, 59, 48, 0.05); 
            color: var(--danger); 
        }

        .analysis-box { 
            margin-top: 24px; 
            padding: 20px; 
            background: rgba(142, 142, 147, 0.05);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 12px; 
            border: 0.5px solid rgba(0,0,0,0.05);
            border-left: 3px solid var(--primary); 
            display: none; 
            opacity: 0; 
            transition: opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1); 
            color: var(--text-sub);
            line-height: 1.6;
        }
        body.dark-mode .analysis-box {
            background: rgba(142, 142, 147, 0.1);
            border-color: rgba(255,255,255,0.1);
            border-left-color: var(--primary);
        }
        .analysis-box.show { opacity: 1; }

        .footer { 
            margin-top: auto; 
            display: flex; 
            justify-content: space-between; 
            padding-top: 24px; 
            border-top: 0.5px solid var(--border-color); 
            position: relative;
            z-index: 5;
        }
        .btn { 
            padding: 12px 24px; 
            border-radius: 12px; 
            border: none; 
            cursor: pointer; 
            font-size: 17px; 
            font-weight: 500; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            -webkit-tap-highlight-color: transparent;
        }
        .btn:hover { 
            transform: translateY(-1px); 
            box-shadow: var(--shadow-hover);
        }
        .btn:active {
            transform: scale(0.97);
        }
        .btn[disabled], .btn[data-loading="true"] { 
            opacity: 0.5; 
            cursor: not-allowed; 
            pointer-events: none; 
        }
        .btn[data-loading="true"] { 
            position: relative; 
            color: transparent; 
        }
        .btn[data-loading="true"]::after { 
            content: ""; 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            width: 18px; 
            height: 18px; 
            margin: -9px 0 0 -9px; 
            border-radius: 50%; 
            border: 2px solid currentColor; 
            border-right-color: transparent; 
            animation: spin .8s linear infinite; 
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .btn-nav { 
            background: rgba(255, 255, 255, 0.65);
            backdrop-filter: blur(40px) saturate(180%);
            -webkit-backdrop-filter: blur(40px) saturate(180%);
            color: var(--text-color);
            border: 0.5px solid var(--border-color);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04), 0 0 0 0.5px rgba(255, 255, 255, 0.9) inset;
        }
        .btn-nav:hover {
            background: rgba(255, 255, 255, 0.85);
            border-color: rgba(0, 0, 0, 0.1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.06), 0 0 0 0.5px rgba(255, 255, 255, 1) inset;
        }
        body.dark-mode .btn-nav {
            background: rgba(28, 28, 30, 0.6);
            border-color: var(--border-color);
        }
        body.dark-mode .btn-nav:hover {
            background: rgba(28, 28, 30, 0.75);
            border-color: rgba(255, 255, 255, 0.18);
        }

        .btn-check { 
            background: rgba(0, 122, 255, 0.08);
            backdrop-filter: blur(40px) saturate(180%);
            -webkit-backdrop-filter: blur(40px) saturate(180%);
            color: var(--primary);
            border: 0.5px solid rgba(0, 122, 255, 0.25);
            box-shadow: 0 1px 2px rgba(0, 122, 255, 0.08), 0 0 0 0.5px rgba(255, 255, 255, 0.9) inset;
        }
        .btn-check:hover {
            background: rgba(0, 122, 255, 0.12);
            border-color: rgba(0, 122, 255, 0.35);
            box-shadow: 0 2px 4px rgba(0, 122, 255, 0.12), 0 0 0 0.5px rgba(255, 255, 255, 1) inset;
        }
        body.dark-mode .btn-check {
            background: rgba(10, 132, 255, 0.15);
            color: var(--primary);
            border-color: rgba(10, 132, 255, 0.3);
        }
        body.dark-mode .btn-check:hover {
            background: rgba(10, 132, 255, 0.2);
            border-color: rgba(10, 132, 255, 0.4);
        }

        .btn-next-green { 
            background: rgba(52, 199, 89, 0.08);
            backdrop-filter: blur(40px) saturate(180%);
            -webkit-backdrop-filter: blur(40px) saturate(180%);
            color: var(--success);
            border: 0.5px solid rgba(52, 199, 89, 0.25);
            box-shadow: 0 1px 2px rgba(52, 199, 89, 0.08), 0 0 0 0.5px rgba(255, 255, 255, 0.9) inset;
            display: none;
        }
        .btn-next-green:hover {
            background: rgba(52, 199, 89, 0.12);
            border-color: rgba(52, 199, 89, 0.35);
            box-shadow: 0 2px 4px rgba(52, 199, 89, 0.12), 0 0 0 0.5px rgba(255, 255, 255, 1) inset;
        }
        body.dark-mode .btn-next-green {
            background: rgba(52, 199, 89, 0.15);
            color: var(--success);
            border-color: rgba(52, 199, 89, 0.3);
        }
        body.dark-mode .btn-next-green:hover {
            background: rgba(52, 199, 89, 0.2);
            border-color: rgba(52, 199, 89, 0.4);
        }

        .btn-submit { 
            background: rgba(175, 82, 222, 0.1);
            backdrop-filter: blur(40px) saturate(180%);
            -webkit-backdrop-filter: blur(40px) saturate(180%);
            color: #af52de;
            border: 0.5px solid rgba(175, 82, 222, 0.3);
            box-shadow: 0 1px 2px rgba(175, 82, 222, 0.1), 0 0 0 0.5px rgba(255, 255, 255, 0.9) inset;
            display: none;
        }
        .btn-submit:hover {
            background: rgba(175, 82, 222, 0.15);
            border-color: rgba(175, 82, 222, 0.4);
            box-shadow: 0 2px 4px rgba(175, 82, 222, 0.15), 0 0 0 0.5px rgba(255, 255, 255, 1) inset;
        }
        body.dark-mode .btn-submit {
            background: rgba(175, 82, 222, 0.15);
            color: #af52de;
            border-color: rgba(175, 82, 222, 0.3);
        }
        body.dark-mode .btn-submit:hover {
            background: rgba(175, 82, 222, 0.2);
            border-color: rgba(175, 82, 222, 0.4);
        }
        
        #toast { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 10px 20px; border-radius: 20px; display: none; z-index: 2000; font-size: 14px;}
        
        .score-modal { text-align: center; }
        .score-circle { width: 120px; height: 120px; border-radius: 50%; border: 8px solid #6610f2; display: flex; flex-direction: column; justify-content: center; align-items: center; margin: 0 auto 20px; color: #6610f2; }
        .score-val { font-size: 40px; font-weight: bold; }
        .score-label { font-size: 12px; }
        .score-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; max-height: 200px; overflow-y: auto; margin-top: 20px; }
        .score-item { padding: 5px; border-radius: 4px; font-size: 12px; cursor: pointer; }
        .score-item.s-correct { background: #d4edda; color: #155724; }
        .score-item.s-wrong { background: #f8d7da; color: #721c24; }

        /* ç©ºçŠ¶æ€ */
        .empty-state { margin-top: 16px; padding: 16px; text-align: center; color: var(--text-sub); background: var(--analysis-bg); border: 1px dashed var(--border-color); border-radius: 8px; }

        /* é€‰é¡¹é«˜äº®æ ·å¼ */
        .correct-opt { color: #28a745 !important; font-weight: bold; background: rgba(40,167,69,0.08) !important; border-radius: 6px; }
        .wrong-opt { color: #dc3545 !important; font-weight: bold; background: rgba(220,53,69,0.08) !important; border-radius: 6px; }

        .question-image-container {
            margin-bottom: 24px;
            text-align: center;
        }
        .question-image-container img {
            max-width: 100%;
            max-height: 400px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }
        /* ç§»åŠ¨ç«¯é€‚é… */
        @media (max-width: 768px) {
            .sidebar { width: 80vw; left: -80vw; }
            .sidebar.open { left: 0; }
            .main-area { padding: 12px; }
            .card-container { padding: 16px; margin: 10px; min-height: auto; }
            .header { display: grid; grid-template-columns: auto 1fr auto; align-items: center; gap: 8px; }
            /* ä¸­é—´æ¨¡å¼å¾½æ ‡ç½®ä¸­ */
            .header > .mode-badge { justify-self: center; }
            /* å³ä¾§åŒºåŸŸåªä¿ç•™â€œé€€å‡ºâ€ï¼Œéšè—è¿›åº¦ä¸ä¸»é¢˜æŒ‰é’® */
            .header > div:last-child { justify-self: end; display: flex; align-items: center; gap: 8px; }
            #progress-text, .header > div:last-child .btn-menu:not(.btn-theme) { display: none !important; }
            .q-content { font-size: 16px; margin-bottom: 16px; }
            .options label { padding: 14px 12px; font-size: 16px; }
            .btn { padding: 12px 16px; font-size: 14px; }
            .progress-bar { margin: 8px 0 0; }
        }
        @media (max-width: 480px) {
            .sidebar { width: 86vw; left: -86vw; }
            .btn-menu { padding: 6px 10px; font-size: 13px; }
            .q-type-label { font-size: 11px; }
            .fav-btn { font-size: 20px; }
            .analysis-box { font-size: 13px; }
            /* è¦†ç›–æˆç»©å¼¹çª—å®½åº¦ */
            .overlay .card-container.score-modal { width: 90vw !important; }
        }

        .shortcut-hint {
            position: fixed;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--card-bg-solid);
            color: var(--text-sub);
            padding: 8px 16px;
            border-radius: 16px;
            font-size: 13px;
            z-index: 1000;
            opacity: 0.8;
            transition: opacity 0.3s;
            pointer-events: none; /* So it doesn't block clicks */
            box-shadow: var(--shadow);
            border: 0.5px solid var(--border-color);
            white-space: nowrap;
        }

        @media (max-width: 768px) {
            .shortcut-hint {
                display: none; /* On mobile, hide the hint to save space */
            }
        }
    </style>
</head>
<body class="{{ 'memo-mode' if mode == 'memo' else ('exam-mode' if mode == 'exam' else '') }}">

    <div id="toast">è¯·å…ˆå®Œæˆä½œç­”ï¼</div>
    <div class="overlay" id="overlay" onclick="toggleSidebar()"></div>

    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-title-row">
                <span>é¢˜ç›®åˆ—è¡¨</span>
                <span style="cursor:pointer; font-size:20px;" onclick="toggleSidebar()">Ã—</span>
            </div>
            {% if mode != 'exam' %}
                <div style="display: flex; gap: 8px; width: 100%;">
                    <button class="btn-menu" style="flex:1; color:#dc3545; border-color:#dc3545;" onclick="clearProgress()">ğŸ—‘ï¸ æ¸…é™¤</button>
                    <script>
                        const params = new URLSearchParams(window.location.search);
                        if (params.get('shuffle_questions') === '1') {
                            document.write('<button class="btn-menu" style="flex:1;" onclick="reshuffle()">ğŸ² é‡æ’</button>');
                        }
                    </script>
                </div>
            {% endif %}
        </div>
        <div class="sidebar-content" id="question-list">
            {% if questions|length == 0 %}
            <div class="empty-state">
                ğŸ—’ï¸ æ²¡æœ‰é¢˜ç›®ï¼Œè¯·é‡æ–°é€‰æ‹©ç§‘ç›®å’Œé¢˜å‹ã€‚
                <div style="margin-top:10px;"><a class="btn-menu" href="/" style="text-decoration:none; padding:8px 12px; border:1px solid var(--border-color); border-radius:6px;">è¿”å›é¦–é¡µ</a></div>
            </div>
            {% else %}
            {% for q in questions %}
            <div class="q-item" id="list-item-{{ loop.index0 }}" onclick="jumpTo({{ loop.index0 }})">
                <span style="width:25px; font-size:12px; color:#999;">{{ loop.index }}</span>
                <span style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex:1;">{{ q.content }}</span>
                {% if mode == 'exam' %}
                    <span style="font-size:12px; color:#6610f2; margin-left:5px;">{{ q.score_val }}åˆ†</span>
                {% endif %}
            </div>
            {% endfor %}
            {% endif %}
        </div>
    </div>

    <div class="main-area">
        <div class="card-container" id="mainCard" data-exam-id="{{ exam_id or '' }}">
            <div class="header">
                <button class="btn-menu" onclick="toggleSidebar()">â˜° åˆ—è¡¨</button>
                
                {% if mode == 'exam' %}
                    <div style="font-size: 18px; font-weight: bold; color: #6610f2;" id="timer">00:00:00</div>
                {% else %}
                    {% set badge_class = 'bg-quiz' %}
                    {% if mode == 'memo' and is_fav_scope %}
                        {% set badge_class = 'bg-fav' %}
                    {% elif mode == 'memo' and is_mis_scope %}
                        {% set badge_class = 'bg-mistakes' %}
                    {% elif mode == 'memo' %}
                        {% set badge_class = 'bg-memo' %}
                    {% elif is_fav_scope %}
                        {% set badge_class = 'bg-fav' %}
                    {% elif is_mis_scope %}
                        {% set badge_class = 'bg-mistakes' %}
                    {% endif %}
                    <div class="mode-badge {{ badge_class }}">
                        {% if mode == 'memo' %}
                            {% if is_fav_scope %}æ”¶è—æœ¬èƒŒé¢˜{% elif is_mis_scope %}é”™é¢˜æœ¬èƒŒé¢˜{% else %}èƒŒé¢˜{% endif %}
                        {% elif is_mis_scope %}é”™é¢˜æœ¬{% elif is_fav_scope %}æ”¶è—æœ¬{% else %}åˆ·é¢˜{% endif %}
                    </div>
                {% endif %}

                <div style="display:flex; align-items:center; gap:10px;">
                    <button class="btn-menu btn-theme" onclick="toggleTheme()">ğŸŒ“</button>
                    <a href="/" style="text-decoration:none; color:var(--text-sub); font-size:14px; padding: 5px 10px; border: 1px solid var(--border-color); border-radius: 4px;">é€€å‡º</a>
                </div>
            </div>
            
            {% if questions|length > 0 %}
            <div class="progress-bar"><div class="progress-fill" id="progress-fill"></div><div class="progress-label" id="progress-label">0 / {{ questions|length }}</div></div>
{% endif %}


            {% for q in questions %}
            <div class="question-box" id="q-{{ loop.index0 }}" 
                 data-type="{{ q.q_type }}" 
                 data-answer="{{ q.answer }}"
                 data-id="{{ q.id }}"
                 data-score="{{ q.score_val if q.score_val else 0 }}"
                 data-index="{{ loop.index0 }}">
                
                {% if mode != 'exam' and logged_in %}
                <div class="fav-btn {{ 'active' if q.is_fav else '' }}" onclick="toggleStar(this, {{ q.id }})" title="æ”¶è—">â˜…</div>
                {% elif mode != 'exam' and not logged_in %}
                <div class="fav-btn" style="opacity:0.4; cursor:not-allowed;" title="ç™»å½•åå¯æ”¶è—">â˜…</div>
                {% endif %}

                <div>
                    <span class="q-type-label">{{ q.q_type }}</span>
                    {% if mode == 'exam' %}<span style="font-size:12px; color:#666;">({{ q.score_val }}åˆ†)</span>{% endif %}
                    <div class="q-content">{{ q.content|replace('\n', '<br>')|safe }}</div>
                <div class="question-image-gallery" data-images='{{ q.image_path_json }}' style="display: none; margin-bottom: 24px;">
                    <div class="gallery-main-image-wrapper" style="position: relative; text-align: center;">
                        <!-- Main image will be injected here -->
                    </div>
                    <div class="gallery-controls" style="display: none; justify-content: center; align-items: center; gap: 15px; margin-top: 10px;">
                        <button class="gallery-prev" style="background: none; border: 1px solid var(--border-color); border-radius: 50%; width: 30px; height: 30px; cursor: pointer;">â€¹</button>
                        <span class="gallery-counter" style="font-size: 12px; color: var(--text-sub);"></span>
                        <button class="gallery-next" style="background: none; border: 1px solid var(--border-color); border-radius: 50%; width: 30px; height: 30px; cursor: pointer;">â€º</button>
                    </div>
                </div>
                </div>

                <div class="input-area">
                    {% if q.q_type == 'é€‰æ‹©é¢˜' %}
                        <div class="options">
                            {% for opt in q.options %}
                                <label>
                                        {% if q.answer|length > 1 %}
                                        <input type="checkbox" value="{{ opt.key }}"> 
                                    {% else %}
                                        <input type="checkbox" value="{{ opt.key }}" onchange="{{ 'markAnswered(' ~ loop.index0 ~ ')' if mode == 'exam' else 'autoCheck()' }}"> 
                                    {% endif %}
                                    <span><strong>{{ opt.key }}.</strong> {{ opt.value }}</span>
                                </label>
                            {% endfor %}
                        </div>
                    {% elif q.q_type == 'åˆ¤æ–­é¢˜' %}
                        <div class="options">
                            <label><input type="radio" name="rad-{{ loop.index0 }}" value="æ­£ç¡®" onchange="{{ 'markAnswered(' ~ loop.index0 ~ ')' if mode == 'exam' else 'autoCheck()' }}"> <span>æ­£ç¡®</span></label>
                            <label><input type="radio" name="rad-{{ loop.index0 }}" value="é”™è¯¯" onchange="{{ 'markAnswered(' ~ loop.index0 ~ ')' if mode == 'exam' else 'autoCheck()' }}"> <span>é”™è¯¯</span></label>
                        </div>
                    {% elif q.q_type == 'å¡«ç©ºé¢˜' %}
                        <div class="fill-in-the-blanks">
                            {% set num_blanks = q.content.count('__') %}
                            {% if num_blanks > 0 %}
                                {% for i in range(num_blanks) %}
                                    <div class="blank-item">
                                        <label>ç©º {{ loop.index }}:</label>
                                        <input type="text" class="main-input" placeholder="è¾“å…¥ç­”æ¡ˆ {{ loop.index }}" oninput="{{ 'markAnswered(' ~ loop.index0 ~ ')' if mode == 'exam' else '' }}">
                                    </div>
                                {% endfor %}
                            {% else %}
                                <input type="text" class="main-input" placeholder="è¾“å…¥ç­”æ¡ˆ" oninput="{{ 'markAnswered(' ~ loop.index0 ~ ')' if mode == 'exam' else '' }}">
                            {% endif %}
                        </div>
                    {% elif q.q_type == 'é—®ç­”é¢˜' %}
                        <textarea class="main-input" rows="4" placeholder="è¯·ä½œç­”..." oninput="{{ 'markAnswered(' ~ loop.index0 ~ ')' if mode == 'exam' else '' }}"></textarea>
                    {% endif %}
                </div>

                <div class="analysis-box">
                    <p><strong>âœ… æ­£ç¡®ç­”æ¡ˆï¼š</strong>{% if q.q_type in ['é—®ç­”é¢˜', 'è®¡ç®—é¢˜', 'ç®€ç­”é¢˜'] %}<br>{% endif %} <span style="color:#28a745; font-weight:bold;">{{ q.answer|replace('\n', '<br>')|safe }}</span></p>
                    {% if q.explanation %}
                    <p style="margin-top:12px;"><strong>ğŸ“ è§£æï¼š</strong> {{ q.explanation|replace('\n', '<br>')|safe }}</p>
                    {% endif %}
                </div>
            </div>
            {% endfor %}

            <div class="footer">
                <button class="btn btn-nav" onclick="prevQuestion()" id="btn-prev">â† ä¸Šä¸€é¢˜</button>
                
                {% if mode == 'exam' %}
                    <button class="btn btn-submit" id="btn-submit-exam" onclick="submitExam()">äº¤å·</button>
                    <button class="btn btn-nav" id="btn-next-exam" onclick="nextQuestion()">ä¸‹ä¸€é¢˜ â†’</button>
                {% else %}
                    <button class="btn btn-check" onclick="checkAnswer(true)" id="btn-check" style="display: {{ 'none' if mode == 'memo' else 'block' }}">ğŸ‘€ æŸ¥çœ‹ç»“æœ</button>
                    <button class="btn btn-next-green" onclick="nextQuestion()" id="btn-next" style="display: {{ 'block' if mode == 'memo' else 'none' }}">ä¸‹ä¸€é¢˜ (Enter) â†’</button>
                {% endif %}
            </div>
        </div>
    </div>

    <div class="overlay" id="scoreOverlay" style="z-index: 2000;">
        <div class="card-container score-modal" style="width: 350px; min-height: auto;">
            <h2 style="margin-top:0;" id="scoreTitle">ğŸ“„ è€ƒè¯•æˆç»©å•</h2>
            <div class="score-circle" id="scoreCircle">
                <div class="score-val" id="finalScore">0</div>
                <div class="score-label" id="finalLabel">æ€»åˆ†</div>
            </div>
            <p id="scoreDetail">ç­”å¯¹ 0 / 0 é¢˜</p>
            {% if mode != 'exam' %}
                <p style="font-size:12px; color:#666; margin-top:-10px;">(é”™é¢˜å·²è‡ªåŠ¨åŠ å…¥é”™é¢˜æœ¬)</p>
            {% endif %}
            <div class="score-grid" id="scoreGrid"></div>
            <div style="margin-top:20px;">
                <button class="btn btn-check" onclick="reviewExam()">ğŸ” å›é¡¾é¢˜ç›®</button>
                <a href="/" class="btn btn-nav" style="text-decoration:none;">é€€å‡º</a>
            </div>
        </div>
    </div>

    <script>
        const mode = '{{ mode }}';
        const source = '{{ source or "" }}';
        const LOGGED_IN = {{ 'true' if logged_in else 'false' }};
        const USER_KEY = "{{ user_id if logged_in else 'guest' }}"; // ç”¨ user_id ä½œä¸ºè¿›åº¦éš”ç¦»é”®
        
        // ä¼˜åŒ–åçš„è¿›åº¦é”®ç”Ÿæˆå‡½æ•° - æ ‡å‡†åŒ–å‚æ•°é¡ºåº,é¿å…é‡å¤è¿›åº¦
        function progressKey(){
            const params = new URLSearchParams(window.location.search);
            const subject = params.get('subject') || 'all';
            const type = params.get('type') || 'all';
            const currentMode = params.get('mode') || mode || 'quiz';
            
            // è€ƒè¯•æ¨¡å¼ä½¿ç”¨exam_idä½œä¸ºå”¯ä¸€æ ‡è¯†
            if (currentMode === 'exam') {
                const examId = params.get('exam_id');
                if (examId) {
                    return `quiz_progress_${USER_KEY}_exam_${examId}`;
                }
            }
            
            // å…¶ä»–æ¨¡å¼ä½¿ç”¨æ ‡å‡†åŒ–çš„ç§‘ç›®+é¢˜å‹+æ¨¡å¼+æ‰“ä¹±è®¾ç½®
            const shuffleQ = params.get('shuffle_questions') === '1' ? '1' : '0';
            const shuffleO = params.get('shuffle_options') === '1' ? '1' : '0';
            return `quiz_progress_${USER_KEY}_${currentMode}_${subject}_${type}_q${shuffleQ}_o${shuffleO}`;
        }
        const questions = document.querySelectorAll('.question-box');
        const EXAM_ID = (function(){ const el = document.getElementById('mainCard'); return el ? (el.dataset.examId || '') : ''; })();
        const EXAM_SUBMITTED = {{ 'true' if submitted else 'false' }};
        const USER_ANSWERS = {{ user_answers_json|safe if user_answers_json else '{}' }};
        const listItems = document.querySelectorAll('.q-item');
        const totalQuestions = {{ questions|length }};
        let currentIndex = 0;
        let isWholeView = false;
        let isSubmitted = false; // æ ‡è®°æ˜¯å¦å·²äº¤å·
        
        let timerSeconds = {{ duration * 60 if duration else 0 }};
        let timerInterval;
        let cachedOrder = null; // ç¼“å­˜é¢˜ç›®é¡ºåºï¼Œä¿å­˜è¿›åº¦æ—¶éœ€è¦ä¿ç•™

        async function init() {
            if (localStorage.getItem('theme') === 'dark') document.body.classList.add('dark-mode');
            if (mode !== 'exam') {
                await preloadProgress();
            }

            if (mode === 'exam') {
                if (EXAM_SUBMITTED) {
                    isSubmitted = true;
                    // å›é¡¾æ¨¡å¼ï¼šé¢„å¡«ç­”æ¡ˆå¹¶å±•ç¤ºè§£æ
                    applyReviewFromServer();
                    const btnSubmit = document.getElementById('btn-submit-exam');
                    if (btnSubmit) btnSubmit.style.display = 'none';
                    const timerEl = document.getElementById('timer');
                    if (timerEl) timerEl.style.display = 'none';
                    const btnNext = document.getElementById('btn-next-exam');
                    if (btnNext) btnNext.style.display = 'block';
                } else {
                    // è¿›è¡Œä¸­è€ƒè¯•ï¼šæ¢å¤æœåŠ¡å™¨è‰ç¨¿å¹¶å¯åŠ¨è‡ªåŠ¨ä¿å­˜
                    applyDraftFromServer();
                    startTimer();
                    const btnNext = document.getElementById('btn-next-exam');
                    if (btnNext) btnNext.style.display = 'block';
                    scheduleAutoSave();
                }
            }

            showQuestion(currentIndex);
        }

        async function preloadProgress(){
            const key = progressKey();
            console.log('[è¿›åº¦åŠ è½½] å½“å‰æ¨¡å¼:', mode, 'è¿›åº¦é”®:', key);

            // ç™»å½•ç”¨æˆ·ä¼˜å…ˆä»æœåŠ¡å™¨æ‹‰å–è¿›åº¦
            if (LOGGED_IN) {
                try {
                    const encodedKey = encodeURIComponent(key);
                    console.log('[è¿›åº¦åŠ è½½] ä»æœåŠ¡å™¨è·å–è¿›åº¦...');
                    const res = await fetch(`/api/progress?key=${encodedKey}`);
                    if (res.ok) {
                        const js = await res.json();
                        console.log('[è¿›åº¦åŠ è½½] æœåŠ¡å™¨å“åº”:', js.status, js.data ? 'æœ‰æ•°æ®' : 'æ— æ•°æ®');
                        if (js.status === 'success' && js.data) {
                            // æ¯”è¾ƒæ—¶é—´æˆ³,ä½¿ç”¨æœ€æ–°çš„è¿›åº¦
                            const serverData = js.data;
                            const localDataStr = localStorage.getItem(key);

                            // ç¼“å­˜æœåŠ¡å™¨çš„é¢˜ç›®é¡ºåºï¼ˆå¦‚æœæœ‰ï¼‰
                            if (serverData.order && Array.isArray(serverData.order)) {
                                cachedOrder = serverData.order;
                            }

                            if (localDataStr) {
                                try {
                                    const localData = JSON.parse(localDataStr);
                                    const serverTime = serverData.timestamp || 0;
                                    const localTime = localData.timestamp || 0;

                                    // ä½¿ç”¨æ—¶é—´æˆ³è¾ƒæ–°çš„æ•°æ®ï¼Œä½†å§‹ç»ˆä¿ç•™orderå­—æ®µ
                                    if (serverTime > localTime) {
                                        localStorage.setItem(key, JSON.stringify(serverData));
                                        console.log('[è¿›åº¦åŠ è½½] ä½¿ç”¨æœåŠ¡å™¨è¿›åº¦(æ›´æ–°)');
                                    } else {
                                        console.log('[è¿›åº¦åŠ è½½] ä½¿ç”¨æœ¬åœ°è¿›åº¦(æ›´æ–°)');
                                        // æœ¬åœ°æ›´æ–°,åŒæ­¥åˆ°æœåŠ¡å™¨ï¼Œä½†ä¿ç•™æœåŠ¡å™¨çš„order
                                        if (localTime > serverTime) {
                                            // åˆå¹¶ï¼šä¿ç•™æœåŠ¡å™¨çš„orderåˆ°æœ¬åœ°æ•°æ®
                                            if (cachedOrder && !localData.order) {
                                                localData.order = cachedOrder;
                                                localStorage.setItem(key, JSON.stringify(localData));
                                            }
                                            syncToServer(localData);
                                        }
                                    }
                                } catch(e) {
                                    // è§£æå¤±è´¥,ä½¿ç”¨æœåŠ¡å™¨æ•°æ®
                                    localStorage.setItem(key, JSON.stringify(serverData));
                                }
                            } else {
                                // æœ¬åœ°æ— æ•°æ®,ä½¿ç”¨æœåŠ¡å™¨æ•°æ®
                                localStorage.setItem(key, JSON.stringify(serverData));
                                console.log('[è¿›åº¦åŠ è½½] ä»æœåŠ¡å™¨åŠ è½½è¿›åº¦');
                            }
                        } else {
                            console.log('[è¿›åº¦åŠ è½½] æœåŠ¡å™¨æ— è¿›åº¦æ•°æ®');
                        }
                    }
                } catch(e) {
                    console.error('[è¿›åº¦åŠ è½½] åŠ è½½æœåŠ¡å™¨è¿›åº¦å¤±è´¥:', e);
                }
            }
            loadState();
        }

        function startTimer() {
            const timerEl = document.getElementById('timer');
            timerInterval = setInterval(() => {
                timerSeconds--;
                if (timerSeconds <= 0) {
                    clearInterval(timerInterval);
                    alert('è€ƒè¯•æ—¶é—´åˆ°ï¼ç³»ç»Ÿå°†è‡ªåŠ¨äº¤å·ã€‚');
                    submitExam(true); 
                    return;
                }
                const h = Math.floor(timerSeconds / 3600).toString().padStart(2,'0');
                const m = Math.floor((timerSeconds % 3600) / 60).toString().padStart(2,'0');
                const s = (timerSeconds % 60).toString().padStart(2,'0');
                timerEl.innerText = `${h}:${m}:${s}`;
            }, 1000);
        }

        function markAnswered(index) {
            const item = document.getElementById(`list-item-${index}`);
            item.classList.add('answered');
        }

        function toggleWholeView() {
            isWholeView = !isWholeView;
            const container = document.getElementById('mainCard');
            const btn = document.getElementById('btn-whole-view');
            
            if (isWholeView) {
                container.classList.add('whole-view');
                btn.innerText = "â†© è¿”å›å•é¢˜";
                window.scrollTo(0, 0); // æ»šå›é¡¶éƒ¨
                
                if(mode === 'exam' && !isSubmitted) { // åªæœ‰æ²¡äº¤å·æ—¶æ‰æ˜¾ç¤ºäº¤å·æŒ‰é’®
                    let tempSubmit = document.getElementById('temp-submit');
                    if(!tempSubmit) {
                        tempSubmit = document.createElement('button');
                        tempSubmit.id = 'temp-submit';
                        tempSubmit.className = 'btn btn-submit';
                        tempSubmit.style.display = 'block';
                        tempSubmit.style.margin = '20px auto';
                        tempSubmit.innerText = 'ğŸ“¤ äº¤å·';
                        tempSubmit.onclick = () => submitExam();
                        container.appendChild(tempSubmit);
                    } else {
                        tempSubmit.style.display = 'block';
                    }
                }
            } else {
                container.classList.remove('whole-view');
                btn.innerText = "æ•´å·é¢„è§ˆ";
                const tempSubmit = document.getElementById('temp-submit');
                if(tempSubmit) tempSubmit.style.display = 'none';
                showQuestion(currentIndex);
            }
        }

        function jumpTo(index) {
            if (isWholeView) {
                const el = document.getElementById('q-' + index);
                if(el) {
                    el.scrollIntoView({behavior: 'smooth', block: 'center'});
                    el.style.transition = 'background 0.3s';
                    el.style.background = 'rgba(0,123,255,0.1)';
                    setTimeout(() => el.style.background = 'transparent', 500);
                }
            } else {
                showQuestion(index);
            }
            toggleSidebar(); 
        }

        function showQuestion(index) {
            if (isWholeView) return; 

            questions.forEach(q => q.classList.remove('active'));
            questions[index].classList.add('active');
            
            listItems.forEach(item => item.classList.remove('active'));
            if(listItems[index]) {
                listItems[index].classList.add('active');
                listItems[index].scrollIntoView({ behavior: 'smooth', block: 'center' });
            }

            // å…ˆæ›´æ–°å½“å‰ç´¢å¼•ï¼Œé¿å…å›é¡¾æ¨¡å¼ä¸‹æ— æ³•ç¿»é¡µ
            currentIndex = index;

            const currentQ = questions[index];
            const type = currentQ.getAttribute('data-type');
            const answer = currentQ.getAttribute('data-answer');
            const analysisBox = currentQ.querySelector('.analysis-box');
            setupImageGallery(currentQ);

            // è‡ªåŠ¨èšç„¦å¡«ç©ºé¢˜/é—®ç­”é¢˜è¾“å…¥æ¡†
            const qType = currentQ.getAttribute('data-type');
            if (qType === 'å¡«ç©ºé¢˜' || qType === 'é—®ç­”é¢˜') {
                const inputField = currentQ.querySelector('.main-input, textarea');
                if (inputField && !inputField.disabled) {
                    // åŠ¨ç”»ç»“æŸåèšç„¦ï¼Œä»¥ç¡®ä¿å…ƒç´ å¯è§
                    setTimeout(() => inputField.focus(), 400); 
                }
            }

            const btnPrev = document.getElementById('btn-prev');
            btnPrev.disabled = (index === 0);

            if (mode === 'exam') {
                const btnNextExam = document.getElementById('btn-next-exam');
                const btnSubmitExam = document.getElementById('btn-submit-exam');
                
                // å¦‚æœå·²äº¤å·ï¼Œéšè—æäº¤æŒ‰é’®ï¼Œä»…ç”¨äºæŸ¥çœ‹ï¼ŒåŒæ—¶æ›´æ–°è¿›åº¦æ¡
                if (isSubmitted) {
                    if (btnNextExam) {
                        btnNextExam.style.display = (index === totalQuestions - 1) ? 'none' : 'block';
                    }
                    if (btnSubmitExam) btnSubmitExam.style.display = 'none';
                    const plabel = document.getElementById('progress-label');
                    if (plabel) plabel.innerText = `${currentIndex + 1} / ${totalQuestions}`;
                    const pf = document.getElementById('progress-fill');
                    if (pf) pf.style.width = ((currentIndex + 1) / totalQuestions * 100) + '%';
                    return;
                }

                if (index === totalQuestions - 1) {
                    btnNextExam.style.display = 'none';
                    btnSubmitExam.style.display = 'block';
                } else {
                    btnNextExam.style.display = 'block';
                    btnSubmitExam.style.display = 'none';
                }
            } else {
                const btnCheck = document.getElementById('btn-check');
                const btnNext = document.getElementById('btn-next');
                
                if (mode === 'memo') {
                    analysisBox.style.display = 'block';
                    analysisBox.classList.add('show');
                    btnCheck.style.display = 'none';
                    btnNext.style.display = 'block';
                    fillAnswer(currentQ, type, answer);
                    disableInputs(currentQ); 
                } else {
                    if (analysisBox.style.display === 'block') {
                        btnCheck.style.display = 'none';
                        btnNext.style.display = 'block';
                    } else {
                        btnCheck.style.display = 'block';
                        btnNext.style.display = 'none';
                    }
                    
                    if (index === totalQuestions - 1) {
                        btnNext.innerText = "å®Œæˆåˆ·é¢˜";
                        btnNext.classList.remove('btn-next-green');
                        btnNext.style.backgroundColor = '#6610f2'; 
                        btnNext.onclick = finishQuiz;
                    } else {
                        btnNext.innerText = "ä¸‹ä¸€é¢˜ (Enter) â†’";
                        btnNext.classList.add('btn-next-green');
                        btnNext.style.backgroundColor = ''; 
                        btnNext.onclick = nextQuestion;
                    }
                }
            }

            currentIndex = index;
            const plabel = document.getElementById('progress-label');
            if (plabel) plabel.innerText = `${currentIndex + 1} / ${totalQuestions}`;
            document.getElementById('progress-fill').style.width = ((currentIndex + 1) / totalQuestions * 100) + '%';
            
            if (mode !== 'exam') saveState();
        }

        function fillAnswer(q, type, answer) {
            if (type === 'é€‰æ‹©é¢˜' || type === 'åˆ¤æ–­é¢˜') {
                q.querySelectorAll('input').forEach(input => {
                    const label = input.parentElement;
                    label.classList.remove('correct-opt');
                    // For choice questions, the value is the key ('A', 'B', etc.)
                    // For judgment questions, the value is 'æ­£ç¡®' or 'é”™è¯¯'
                    if (answer.includes(input.value)) {
                        label.classList.add('correct-opt');
                        input.checked = true;
                    }
                });
            } else if (type === 'å¡«ç©ºé¢˜') {
                const inputs = q.querySelectorAll('.main-input');
                const correctBlanks = answer.split(';;').map(a => a.trim());

                inputs.forEach((input, i) => {
                    // é»˜è®¤å¡«å……æ¯ä¸ªç©ºçš„ç¬¬ä¸€ä¸ªæ­£ç¡®ç­”æ¡ˆ
                    const firstCorrectAnswer = (correctBlanks[i] || '').split(';')[0].trim();
                    input.value = firstCorrectAnswer;
                    input.classList.add('input-correct');
                });
            }
        }

        function disableInputs(q) {
            q.classList.add('checked-mode');
            q.querySelectorAll('input, textarea').forEach(el => el.disabled = true);
        }

        function autoCheck() {
            checkAnswer(false);
        }

        function checkAnswer(isManualClick) {
            if (mode === 'exam') return;

            const currentQ = questions[currentIndex];
            const type = currentQ.getAttribute('data-type');
            const answer = currentQ.getAttribute('data-answer');
            const qId = currentQ.getAttribute('data-id');
            const analysisBox = currentQ.querySelector('.analysis-box');
            
            if (!hasAnswered(currentQ, type)) {
                if (isManualClick) showToast("è¯·å…ˆä½œç­”ï¼");
                return;
            }

            analysisBox.style.display = 'block';
            setTimeout(() => analysisBox.classList.add('show'), 10);
            
            document.getElementById('btn-check').style.display = 'none';
            document.getElementById('btn-next').style.display = 'block';
            
            let isCorrect = judgeQuestion(currentQ, type, answer);
            styleFeedback(currentQ, type, answer, isCorrect);
            
            disableInputs(currentQ);

            const listItem = document.getElementById(`list-item-${currentIndex}`);
            if (isCorrect) {
                listItem.classList.add('done-correct');
                listItem.classList.remove('done-wrong');
            } else {
                listItem.classList.add('done-wrong');
                listItem.classList.remove('done-correct');
            }

            if (LOGGED_IN) {
            fetch('/api/record_result', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ question_id: qId, is_correct: isCorrect })
            });
            } else {
                // æœªç™»å½•ä¸å†™å…¥é”™é¢˜æœ¬ï¼Œåªåœ¨æœ¬åœ°ä¿ç•™æ•ˆæœ
                showToast('æœªç™»å½•ï¼šé”™é¢˜ä¸ä¼šä¿å­˜åˆ°æœåŠ¡å™¨');
            }

            saveState(true); // ç­”é¢˜åç«‹å³åŒæ­¥åˆ°æœåŠ¡å™¨
        }

        function finishQuiz() {
            let correctCount = 0;
            let gridHtml = '';
            
            listItems.forEach((item, index) => {
                const isRight = item.classList.contains('done-correct');
                const isWrong = item.classList.contains('done-wrong');
                
                if (isRight) correctCount++;
                
                if (isRight) {
                    gridHtml += `<div class="score-item s-correct" onclick="reviewJump(${index})">${index+1}</div>`;
                } else if (isWrong) {
                    gridHtml += `<div class="score-item s-wrong" onclick="reviewJump(${index})">${index+1}</div>`;
                } else {
                    gridHtml += `<div class="score-item" onclick="reviewJump(${index})">${index+1}</div>`;
                }
            });

            document.getElementById('scoreTitle').innerText = "åˆ·é¢˜æŠ¥å‘Š";
            document.getElementById('finalLabel').innerText = "å‡†ç¡®ç‡";
            document.getElementById('finalScore').innerText = Math.round((correctCount / totalQuestions) * 100) + "%";
            document.getElementById('scoreDetail').innerText = `ç­”å¯¹ ${correctCount} / ${totalQuestions} é¢˜`;
            document.getElementById('scoreGrid').innerHTML = gridHtml;
            document.getElementById('scoreOverlay').style.display = 'flex';
            
            document.getElementById('scoreCircle').style.borderColor = '#007bff';
            document.getElementById('scoreCircle').style.color = '#007bff';
        }

        function submitExam(force = false) {
            // æœåŠ¡ç«¯æäº¤è€ƒè¯•ç­”æ¡ˆï¼ˆè‹¥å­˜åœ¨ exam_idï¼‰
            try { sendExamAnswers(); } catch(e) {}
            if (isSubmitted) return; // ã€ä¿®å¤ã€‘å¦‚æœå·²äº¤å·ï¼Œç›´æ¥é˜»æ–­

            if (!force) {
                let unAnsweredIndices = [];
                questions.forEach((q, i) => {
                    const type = q.getAttribute('data-type');
                    if (!hasAnswered(q, type)) {
                        unAnsweredIndices.push(i + 1);
                    }
                });

                if (unAnsweredIndices.length > 0) {
                    alert(`è¿˜æœ‰ ${unAnsweredIndices.length} é“é¢˜æœªä½œç­”ï¼\né¢˜å·ï¼š${unAnsweredIndices.join(', ')}`);
                    if (!isWholeView) showQuestion(unAnsweredIndices[0] - 1);
                    return;
                }
                
                if (!confirm("ç¡®å®šè¦äº¤å·å—ï¼Ÿäº¤å·åå°†æ˜¾ç¤ºæˆç»©ã€‚")) return;
            }

            // ã€ä¿®å¤ã€‘ç«‹å³æ›´æ–°çŠ¶æ€å¹¶éšè—æ‰€æœ‰äº¤å·æŒ‰é’®
            isSubmitted = true;
            const mainSubmitBtn = document.getElementById('btn-submit-exam');
            const tempSubmitBtn = document.getElementById('temp-submit');
            if(mainSubmitBtn) mainSubmitBtn.style.display = 'none';
            if(tempSubmitBtn) tempSubmitBtn.remove();
            
            clearInterval(timerInterval);
            let totalScore = 0;
            let correctCount = 0;
            let gridHtml = '';

            questions.forEach((q, index) => {
                const type = q.getAttribute('data-type');
                const answer = q.getAttribute('data-answer');
                const scoreVal = parseFloat(q.getAttribute('data-score'));
                
                const isCorrect = judgeQuestion(q, type, answer);
                styleFeedback(q, type, answer, isCorrect);
                q.querySelector('.analysis-box').style.display = 'block';
                q.querySelector('.analysis-box').classList.add('show');
                disableInputs(q);

                if (isCorrect) {
                    totalScore += scoreVal;
                    correctCount++;
                    gridHtml += `<div class="score-item s-correct" onclick="reviewJump(${index})">${index+1}</div>`;
                } else {
                    gridHtml += `<div class="score-item s-wrong" onclick="reviewJump(${index})">${index+1}</div>`;
                }
            });

            document.getElementById('finalScore').innerText = totalScore;
            document.getElementById('scoreDetail').innerText = `ç­”å¯¹ ${correctCount} / ${totalQuestions} é¢˜`;
            document.getElementById('scoreGrid').innerHTML = gridHtml;
            document.getElementById('scoreOverlay').style.display = 'flex';
        }

        function reviewExam() {
            document.getElementById('scoreOverlay').style.display = 'none';
            
            // è€ƒè¯•æ¨¡å¼ä¸‹ï¼Œå›é¡¾æ—¶ä¸å†æ˜¾ç¤ºäº¤å·æŒ‰é’®ï¼Œç¡®ä¿åªèƒ½ä¸‹ä¸€é¢˜æŸ¥çœ‹
            if (mode === 'exam') {
                const btnSubmit = document.getElementById('btn-submit-exam');
                if(btnSubmit) btnSubmit.style.display = 'none';
                
                const btnNext = document.getElementById('btn-next-exam');
                if(btnNext) btnNext.style.display = 'block';
            }
            
            if (!isWholeView) {
                currentIndex = 0;
                showQuestion(0);
            }
            
            const tempSubmit = document.getElementById('temp-submit');
            if(tempSubmit) tempSubmit.remove();
        }
        
        function reviewJump(index) {
            reviewExam();
            if (isWholeView) {
                jumpTo(index); 
            } else {
                showQuestion(index);
            }
        }

        function judgeQuestion(q, type, answer) {
            if (type === 'é€‰æ‹©é¢˜' || type === 'åˆ¤æ–­é¢˜') {
                const inputs = q.querySelectorAll('input');
                let userVals = [];
                inputs.forEach(i => { if(i.checked) userVals.push(i.value) });
                return userVals.sort().join("") === answer;
            } else if (type === 'å¡«ç©ºé¢˜') {
                const inputs = q.querySelectorAll('.main-input');
                const correctBlanks = answer.split(';;').map(a => a.trim());

                if (inputs.length === 0) return false; // æ²¡æœ‰æ‰¾åˆ°è¾“å…¥æ¡†

                let allCorrect = true;
                for (let i = 0; i < inputs.length; i++) {
                    const userInput = inputs[i].value.trim();
                    const correctAnswersForBlank = (correctBlanks[i] || '').split(';').map(a => a.trim());
                    if (!correctAnswersForBlank.includes(userInput)) {
                        allCorrect = false;
                        break;
                    }
                }
                return allCorrect;
            } else if (type === 'é—®ç­”é¢˜') {
                return !!q.querySelector('textarea').value.trim();
            }
            return false;
        }

        function hasAnswered(q, type) {
            if (type === 'é€‰æ‹©é¢˜' || type === 'åˆ¤æ–­é¢˜') return q.querySelector('input:checked');
            if (type === 'å¡«ç©ºé¢˜') return q.querySelector('input').value.trim();
            if (type === 'é—®ç­”é¢˜') return q.querySelector('textarea').value.trim();
            return false;
        }

        function styleFeedback(q, type, answer, isCorrect) {
            if (type === 'é€‰æ‹©é¢˜' || type === 'åˆ¤æ–­é¢˜') {
                q.querySelectorAll('input').forEach(input => {
                    const label = input.parentElement;
                    label.classList.remove('correct-opt', 'wrong-opt');
                    if (isCorrect) {
                        // åšå¯¹æ—¶ï¼Œç”¨æˆ·é€‰ä¸­çš„éƒ½ç»¿è‰²
                        if (input.checked) label.classList.add('correct-opt');
                    } else {
                        // åšé”™æ—¶ï¼Œç”¨æˆ·é€‰ä¸­çš„é”™è¯¯é€‰é¡¹æ ‡çº¢
                        if (input.checked && !answer.includes(input.value)) {
                            label.classList.add('wrong-opt');
                        }
                        // æ€»æ˜¯é«˜äº®æ­£ç¡®ç­”æ¡ˆ
                        if (answer.includes(input.value)) {
                            label.classList.add('correct-opt');
                        }
                    }
                });
            } else if (type === 'å¡«ç©ºé¢˜') {
                const inputs = q.querySelectorAll('.main-input');
                const correctBlanks = answer.split(';;').map(a => a.trim());

                inputs.forEach((input, i) => {
                    input.classList.remove('input-correct', 'input-wrong');
                    const userInput = input.value.trim();
                    const correctAnswersForBlank = (correctBlanks[i] || '').split(';').map(a => a.trim());
                    
                    if (correctAnswersForBlank.includes(userInput)) {
                        input.classList.add('input-correct');
                    } else {
                        input.classList.add('input-wrong');
                    }
                });
            }
            // åˆ·é¢˜æ¨¡å¼ä¸‹ï¼Œé¢˜ç›®åˆ—è¡¨é«˜äº®
            if (mode !== 'exam') {
                const idx = q.getAttribute('data-index');
                const item = document.getElementById(`list-item-${idx}`);
                if (item) {
                    item.classList.remove('done-correct', 'done-wrong');
                    if (isCorrect) {
                        item.classList.add('done-correct');
                    } else {
                        item.classList.add('done-wrong');
                    }
                }
            }
        }

        // é˜²æŠ–å®šæ—¶å™¨
        let saveStateTimer = null;
        let lastSavedPayload = null;
        let syncPending = false; // æ ‡è®°æ˜¯å¦æœ‰å¾…åŒæ­¥çš„æ•°æ®

        // ä¿ç•™åšé¢˜ç—•è¿¹æ ·å¼ - å¸¦é˜²æŠ–æœºåˆ¶
        function saveState(immediate = false) {
            let statusMap = {};
            let answerMap = {};
            listItems.forEach((item, index) => {
                if (item.classList.contains('done-correct')) statusMap[index] = 'correct';
                if (item.classList.contains('done-wrong')) statusMap[index] = 'wrong';
                // ä¿å­˜ç”¨æˆ·é€‰é¡¹/ç­”æ¡ˆ
                const q = document.getElementById(`q-${index}`);
                if (q) {
                    const type = q.getAttribute('data-type');
                    if (type === 'é€‰æ‹©é¢˜' || type === 'åˆ¤æ–­é¢˜') {
                        const checked = Array.from(q.querySelectorAll('input:checked')).map(i => i.value);
                        answerMap[index] = checked;
                    } else if (type === 'å¡«ç©ºé¢˜') {
                        const inputs = q.querySelectorAll('.main-input');
                        answerMap[index] = Array.from(inputs).map(input => input.value);

                    } else if (type === 'é—®ç­”é¢˜') {
                        answerMap[index] = q.querySelector('textarea').value;
                    }
                }
            });
            const payload = { index: currentIndex, status: statusMap, answers: answerMap, timestamp: Date.now() };
            // ä¿ç•™é¢˜ç›®é¡ºåºï¼Œé˜²æ­¢è¦†ç›–æœåŠ¡ç«¯ä¿å­˜çš„æ‰“ä¹±é¡ºåº
            if (cachedOrder) {
                payload.order = cachedOrder;
            }

            // ç«‹å³ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
            localStorage.setItem(progressKey(), JSON.stringify(payload));
            lastSavedPayload = payload;
            syncPending = true;

            // ç™»å½•ç”¨æˆ·åŒæ­¥åˆ°æœåŠ¡å™¨
            if (LOGGED_IN) {
                if (immediate) {
                    // ç«‹å³åŒæ­¥ï¼ˆç­”é¢˜åç­‰é‡è¦æ“ä½œï¼‰
                    if (saveStateTimer) clearTimeout(saveStateTimer);
                    syncToServer(payload);
                } else {
                    // é˜²æŠ–ä¿å­˜ï¼ˆ200mså†…å¤šæ¬¡è°ƒç”¨åªæ‰§è¡Œæœ€åä¸€æ¬¡ï¼‰
                    if (saveStateTimer) clearTimeout(saveStateTimer);
                    saveStateTimer = setTimeout(() => {
                        syncToServer(payload);
                    }, 200);
                }
            }
        }

        // åŒæ­¥åˆ°æœåŠ¡å™¨
        async function syncToServer(payload) {
            if (!LOGGED_IN) return;
            try {
                const key = progressKey();
                console.log('[è¿›åº¦åŒæ­¥] ä¿å­˜ä¸­...', key);
                const res = await fetch('/api/progress', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ key: key, data: payload })
                });
                if (res.ok) {
                    syncPending = false;
                    console.log('[è¿›åº¦åŒæ­¥] æˆåŠŸ');
                } else {
                    console.error('[è¿›åº¦åŒæ­¥] æœåŠ¡å™¨é”™è¯¯:', res.status);
                }
            } catch(e) {
                console.error('[è¿›åº¦åŒæ­¥] å¤±è´¥:', e);
            }
        }

        // é¡µé¢å¸è½½æ—¶å¼ºåˆ¶åŒæ­¥
        window.addEventListener('beforeunload', function(e) {
            if (LOGGED_IN && syncPending && lastSavedPayload) {
                try {
                    const key = progressKey();
                    const data = JSON.stringify({ key: key, data: lastSavedPayload });
                    // ä½¿ç”¨ sendBeacon ç¡®ä¿æ•°æ®å‘é€
                    if (navigator.sendBeacon) {
                        const blob = new Blob([data], {type: 'application/json'});
                        navigator.sendBeacon('/api/progress', blob);
                        console.log('[è¿›åº¦åŒæ­¥] beforeunload å‘é€æˆåŠŸ');
                    }
                } catch(err) {
                    console.error('[è¿›åº¦åŒæ­¥] beforeunload å‘é€å¤±è´¥:', err);
                }
            }
        });

        // é¡µé¢éšè—æ—¶ä¹Ÿå°è¯•åŒæ­¥ï¼ˆåˆ‡æ¢æ ‡ç­¾é¡µç­‰ï¼‰
        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState === 'hidden' && LOGGED_IN && syncPending && lastSavedPayload) {
                syncToServer(lastSavedPayload);
            }
        });

        function loadState() {
            try {
                const data = JSON.parse(localStorage.getItem(progressKey()));
                if (data) {
                    // ç¼“å­˜é¢˜ç›®é¡ºåºï¼Œä¿å­˜æ—¶éœ€è¦ä¿ç•™
                    if (data.order && Array.isArray(data.order)) {
                        cachedOrder = data.order;
                    }
                    if (data.status) {
                        for (const [idx, status] of Object.entries(data.status)) {
                            const item = document.getElementById(`list-item-${idx}`);
                            if (item) {
                                if (status === 'correct') item.classList.add('done-correct');
                                if (status === 'wrong') item.classList.add('done-wrong');
                            }
                            const q = document.getElementById(`q-${idx}`);
                            if (q && (status === 'correct' || status === 'wrong')) {
                                const type = q.getAttribute('data-type');
                                const answer = q.getAttribute('data-answer');
                                const isCorrect = status === 'correct';

                                // 1. æ¢å¤ç”¨æˆ·çš„é€‰æ‹© (å¿…é¡»åœ¨ styleFeedback ä¹‹å‰)
                                if (data.answers && data.answers[idx]) {
                                    const userAnswer = data.answers[idx];
                                    if ((type === 'é€‰æ‹©é¢˜' || type === 'åˆ¤æ–­é¢˜') && Array.isArray(userAnswer)) {
                                        q.querySelectorAll('input').forEach(i => { i.checked = userAnswer.includes(i.value); });
                                    } else if (type === 'å¡«ç©ºé¢˜') {
                                        q.querySelector('input').value = userAnswer;
                                    } else if (type === 'é—®ç­”é¢˜') {
                                        q.querySelector('textarea').value = userAnswer;
                                    }
                                }

                                // 2. æ¢å¤é«˜äº®æ•ˆæœ
                                styleFeedback(q, type, answer, isCorrect);

                                // 3. å±•å¼€è§£æå¹¶ç¦ç”¨è¾“å…¥
                                const analysisBox = q.querySelector('.analysis-box');
                                if (analysisBox) {
                                    analysisBox.style.display = 'block';
                                    analysisBox.classList.add('show');
                                }
                                disableInputs(q);
                            }
                        }
                    }
                    if (data.answers) {
                        for (const [idx, val] of Object.entries(data.answers)) {
                            const q = document.getElementById(`q-${idx}`);
                            if (q) {
                                const type = q.getAttribute('data-type');
                                if ((type === 'é€‰æ‹©é¢˜' || type === 'åˆ¤æ–­é¢˜') && Array.isArray(val)) {
                                    q.querySelectorAll('input').forEach(i => { i.checked = val.includes(i.value); });
                                } else if (type === 'å¡«ç©ºé¢˜' && Array.isArray(val)) {
                                    const inputs = q.querySelectorAll('.main-input');
                                    inputs.forEach((input, i) => {
                                        if (val[i]) {
                                            input.value = val[i];
                                        }
                                    });
                                } else if (type === 'é—®ç­”é¢˜') {
                                    q.querySelector('textarea').value = val;
                                }
                            }
                        }
                    }
                    if (data.index) currentIndex = data.index;
                }
            } catch(e) {}
        }
        
        function resetQuizUI(){
            // æ¸…ç©ºåˆ—è¡¨çŠ¶æ€
            document.querySelectorAll('.q-item').forEach(item=>{
                item.classList.remove('done-correct','done-wrong','answered');
            });
            // æ¸…ç©ºé¢˜ç›®çŠ¶æ€
            questions.forEach((q)=>{
                q.classList.remove('checked-mode');
                // å–æ¶ˆé€‰ä¸­å’Œç¦ç”¨
                q.querySelectorAll('input, textarea').forEach(el=>{
                    el.disabled=false;
                    if(el.type==='checkbox' || el.type==='radio') el.checked=false;
                    else el.value='';
                });
                // å»æ‰é«˜äº®
                q.querySelectorAll('.correct-opt, .wrong-opt, .input-correct, .input-wrong').forEach(el=>{
                    el.classList.remove('correct-opt','wrong-opt','input-correct','input-wrong');
                });
                // éšè—è§£æ
                const ab = q.querySelector('.analysis-box');
                if(ab){ab.style.display='none';ab.classList.remove('show');}
            });
            // é‡ç½®æŒ‰é’®æ˜¾ç¤ºçŠ¶æ€
            const btnCheck=document.getElementById('btn-check');
            const btnNext=document.getElementById('btn-next');
            if(btnCheck) btnCheck.style.display='block';
            if(btnNext) btnNext.style.display='none';

            currentIndex=0;
            showQuestion(0);
        }

        async function clearProgress(confirmMsg = "ç¡®å®šè¦æ¸…é™¤å½“å‰æ¨¡å¼çš„åšé¢˜è¿›åº¦å—ï¼Ÿ") {
            if(confirm(confirmMsg)) {
                localStorage.removeItem(progressKey());
                if (LOGGED_IN) {
                    try { await fetch(`/api/progress?key=${encodeURIComponent(progressKey())}`, { method: 'DELETE' }); } catch(e) {}
                }
                resetQuizUI(); // Reset the UI to its initial state
                showToast('è¿›åº¦å·²æ¸…é™¤');
                return true; // Indicates data was cleared
            }
            return false; // User cancelled
        }

        async function reshuffle() {
            const confirmed = confirm("é‡æ–°æ‰“ä¹±å°†æ¸…ç©ºå½“å‰è¿›åº¦ï¼Œç¡®å®šè¦ç»§ç»­å—ï¼Ÿ");
            if (confirmed) {
                // 1. Clear progress data without reloading
                localStorage.removeItem(progressKey());
                if (LOGGED_IN) {
                    try { await fetch(`/api/progress?key=${encodeURIComponent(progressKey())}`, { method: 'DELETE' }); } catch(e) {}
                }

                // 2. Get all question elements
                const mainCard = document.getElementById('mainCard');
                const questionBoxes = Array.from(mainCard.querySelectorAll('.question-box'));
                const sidebarList = document.getElementById('question-list');
                const listItemsElements = Array.from(sidebarList.querySelectorAll('.q-item'));

                // 3. Create a mapping from original DOM index to elements
                const questionMap = {};
                questionBoxes.forEach((box, i) => {
                    questionMap[i] = { box: box, item: listItemsElements[i] };
                });

                // 4. Shuffle the indices
                let indices = Object.keys(questionMap).map(Number);
                for (let i = indices.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [indices[i], indices[j]] = [indices[j], indices[i]];
                }

                // 5. Re-append elements in the new order and update attributes
                const footer = mainCard.querySelector('.footer');
                questionBoxes.forEach(box => box.remove());
                listItemsElements.forEach(item => item.remove());

                indices.forEach((originalIndex, newIndex) => {
                    const pair = questionMap[originalIndex];
                    const box = pair.box;
                    const item = pair.item;

                    // Update question box
                    box.id = `q-${newIndex}`;
                    box.dataset.index = newIndex;
                    mainCard.insertBefore(box, footer);

                    // Update list item
                    item.id = `list-item-${newIndex}`;
                    item.querySelector('span:first-child').textContent = newIndex + 1;
                    item.setAttribute('onclick', `jumpTo(${newIndex})`);
                    sidebarList.appendChild(item);
                });

                // 6. Reset UI state
                window.questions = document.querySelectorAll('.question-box');
                window.listItems = document.querySelectorAll('.q-item');
                
                window.questions.forEach((q, index) => {
                    q.classList.remove('checked-mode');
                    q.querySelectorAll('input, textarea').forEach(el => {
                        el.disabled = false;
                        if (el.type === 'checkbox' || el.type === 'radio') el.checked = false;
                        else el.value = '';
                    });
                    q.querySelectorAll('.correct-opt, .wrong-opt, .input-correct, .input-wrong').forEach(el => {
                        el.classList.remove('correct-opt', 'wrong-opt', 'input-correct', 'input-wrong');
                    });
                    const analysisBox = q.querySelector('.analysis-box');
                    if (analysisBox) {
                        analysisBox.style.display = 'none';
                        analysisBox.classList.remove('show');
                    }
                });
                window.listItems.forEach(item => {
                    item.classList.remove('done-correct', 'done-wrong', 'answered');
                });

                // 7. Show the first question
                currentIndex = 0;
                showQuestion(0);
                showToast('é¢˜ç›®å·²é‡æ–°æ’åº');
            }
        }
        
        function showToast(msg) {
            const t = document.getElementById('toast');
            t.innerText = msg;
            t.style.display = 'block';
            setTimeout(() => t.style.display = 'none', 2000);
        }
        
        function toggleSidebar() {
            document.getElementById('sidebar').classList.toggle('open');
            document.getElementById('overlay').classList.toggle('show');
        }

        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            localStorage.setItem('theme', document.body.classList.contains('dark-mode') ? 'dark' : 'light');
        }

        function toggleStar(btn, id) {
             fetch('/api/favorite', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ question_id: id })
            }).then(res => res.json()).then(data => {
                if(data.status === 'success') {
                    btn.classList.toggle('active');
                }
            });
        }

        function applyReviewFromServer() {
            try {
                const uaMap = USER_ANSWERS || {};
                questions.forEach(q => {
                    const qid = parseInt(q.getAttribute('data-id'));
                    const type = q.getAttribute('data-type');
                    const stdAns = q.getAttribute('data-answer');
                    const ua = uaMap[qid] || '';
                    // å¡«å……ç”¨æˆ·ç­”æ¡ˆ
                    if (type === 'é€‰æ‹©é¢˜') {
                        const chosen = new Set((ua || '').split(''));
                        q.querySelectorAll('input[type="checkbox"]').forEach(i => { i.checked = chosen.has(i.value); });
                    } else if (type === 'åˆ¤æ–­é¢˜') {
                        q.querySelectorAll('input[type="radio"]').forEach(i => { i.checked = (i.value === ua); });
                    } else if (type === 'å¡«ç©ºé¢˜') {
                        const inp = q.querySelector('input[type="text"]'); if (inp) inp.value = ua;
                    } else {
                        const ta = q.querySelector('textarea'); if (ta) ta.value = ua;
                    }
                    // å±•ç¤ºè§£æä¸é«˜äº®
                    const isCorrect = (function(){
                        if (type === 'é€‰æ‹©é¢˜') return (ua.split('').sort().join('') === (stdAns||'').split('').sort().join('')) && ua !== '';
                        if (type === 'åˆ¤æ–­é¢˜') return ua === stdAns && ua !== '';
                        if (type === 'å¡«ç©ºé¢˜') return ua && (ua.trim() === (stdAns||'').trim());
                        return !!ua;
                    })();
                    styleFeedback(q, type, stdAns, isCorrect);
                    const ab = q.querySelector('.analysis-box'); if (ab){ ab.style.display='block'; ab.classList.add('show'); }
                    disableInputs(q);
                });
                // åˆå§‹åŒ–è¿›åº¦æ¡
                const plabel = document.getElementById('progress-label');
                if (plabel) plabel.innerText = `1 / ${questions.length}`;
                const pf = document.getElementById('progress-fill');
                if (pf) pf.style.width = (questions.length? (1/questions.length*100):0)+'%';
            } catch(e) {}
        }

        function collectExamAnswers() {
            const arr = [];
            questions.forEach(q => {
                const qid = parseInt(q.getAttribute('data-id'));
                const type = q.getAttribute('data-type');
                let ua = '';
                if (type === 'é€‰æ‹©é¢˜') {
                    ua = Array.from(q.querySelectorAll('input[type="checkbox"]:checked')).map(i=>i.value).join('');
                } else if (type === 'åˆ¤æ–­é¢˜') {
                    const r = q.querySelector('input[type="radio"]:checked');
                    ua = r ? r.value : '';
                } else if (type === 'å¡«ç©ºé¢˜') {
                    const i = q.querySelector('input[type="text"]');
                    ua = i ? (i.value || '') : '';
                } else {
                    const t = q.querySelector('textarea');
                    ua = t ? (t.value || '') : '';
                }
                arr.push({ question_id: qid, user_answer: ua });
            });
            return arr;
        }
        async function sendExamAnswers() {
            if (!EXAM_ID) return;
            try {
                const answers = collectExamAnswers();
                const res = await fetch('/api/exams/submit', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ exam_id: EXAM_ID, answers }) });
                const js = await res.json();
                if (res.ok && js.status === 'success') {
                    // ä»¥æœåŠ¡ç«¯ç»“æœä¸ºå‡†æ›´æ–°åˆ†æ•°ä¸ç»Ÿè®¡
                    if (typeof js.total_score !== 'undefined') {
                        const fs = document.getElementById('finalScore');
                        if (fs) fs.innerText = js.total_score;
                    }
                    if (typeof js.total !== 'undefined' && typeof js.correct !== 'undefined') {
                        const sd = document.getElementById('scoreDetail');
                        if (sd) sd.innerText = `ç­”å¯¹ ${js.correct} / ${js.total} é¢˜`;
                    }
                }
            } catch(e) { /* å¿½ç•¥ç½‘ç»œé”™è¯¯ */ }
        }

        function applyDraftFromServer(){
            try {
                const uaMap = USER_ANSWERS || {};
                questions.forEach(q => {
                    const qid = parseInt(q.getAttribute('data-id'));
                    const type = q.getAttribute('data-type');
                    const ua = uaMap[qid] || '';
                    if (!ua) return;
                    if (type === 'é€‰æ‹©é¢˜') {
                        const chosen = new Set((ua || '').split(''));
                        q.querySelectorAll('input[type="checkbox"]').forEach(i => { i.checked = chosen.has(i.value); });
                    } else if (type === 'åˆ¤æ–­é¢˜') {
                        q.querySelectorAll('input[type="radio"]').forEach(i => { i.checked = (i.value === ua); });
                    } else if (type === 'å¡«ç©ºé¢˜') {
                        const inp = q.querySelector('input[type="text"]'); if (inp) inp.value = ua;
                    } else {
                        const ta = q.querySelector('textarea'); if (ta) ta.value = ua;
                    }
                });
            } catch(e) {}
        }
        let autoSaveTimer = null;
        function scheduleAutoSave(){
            if (!EXAM_ID) return;
            try {
                window.addEventListener('beforeunload', function(){
                    try {
                        const payload = JSON.stringify({ exam_id: EXAM_ID, answers: collectExamAnswers() });
                        if (navigator.sendBeacon) {
                            const blob = new Blob([payload], {type: 'application/json'});
                            navigator.sendBeacon('/api/exams/save_draft', blob);
                        }
                    } catch(e){}
                });
            } catch(e){}
            autoSaveTimer = setInterval(async ()=>{
                try {
                    const answers = collectExamAnswers();
                    await fetch('/api/exams/save_draft', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ exam_id: EXAM_ID, answers }) });
                } catch(e) {}
            }, 5000);
        }

        // Mobile swipe gesture for next/prev question
        const mainCard = document.getElementById('mainCard');
        if (mainCard) {
            let touchStartX = 0;
            let touchStartY = 0;

            mainCard.addEventListener('touchstart', e => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }, { passive: true });

            mainCard.addEventListener('touchend', e => {
                const touchEndX = e.changedTouches[0].screenX;
                const touchEndY = e.changedTouches[0].screenY;
                handleSwipe(touchStartX, touchStartY, touchEndX, touchEndY);
            }, { passive: true });
        }

        function handleSwipe(startX, startY, endX, endY) {
            const diffX = endX - startX;
            const diffY = endY - startY;

            // Only trigger if horizontal swipe is significant and vertical swipe is not
            if (Math.abs(diffX) > 200 && Math.abs(diffY) < 200) {
                if (diffX < 0) {
                    // Swiped left
                    nextQuestion();
                } else {
                    // Swiped right
                    prevQuestion();
                }
            }
        }

        init();

        document.addEventListener('keydown', function(e) {
            const isInputFocused = document.activeElement.tagName === 'INPUT';
            const isTextareaFocused = document.activeElement.tagName === 'TEXTAREA';

            // å¦‚æœæˆç»©å¼¹çª—æ˜¾ç¤ºï¼Œåˆ™ç¦ç”¨æ‰€æœ‰å¿«æ·é”®
            if (document.getElementById('scoreOverlay').style.display === 'flex') {
                return;
            }

            // Enter é”®çš„é€»è¾‘
            if (e.key === 'Enter') {
                // å½“ç„¦ç‚¹åœ¨é—®ç­”é¢˜çš„æ–‡æœ¬åŸŸæ—¶ï¼Œå…è®¸é»˜è®¤çš„æ¢è¡Œè¡Œä¸º
                if (isTextareaFocused) {
                    return;
                }
                // é˜»æ­¢å…¶ä»–æ‰€æœ‰ Enter çš„é»˜è®¤è¡Œä¸ºï¼ˆæ¯”å¦‚è¡¨å•æäº¤ï¼‰
                e.preventDefault();

                // ä¼˜å…ˆç‚¹å‡»â€œä¸‹ä¸€é¢˜â€æŒ‰é’®ï¼ˆåŒ…æ‹¬æ™®é€šæ¨¡å¼å’Œè€ƒè¯•æ¨¡å¼ï¼‰
                const btnNext = document.getElementById('btn-next');
                if (btnNext && btnNext.style.display !== 'none') {
                    btnNext.click();
                    return;
                }
                const btnNextExam = document.getElementById('btn-next-exam');
                if (btnNextExam && btnNextExam.style.display !== 'none') {
                    btnNextExam.click();
                    return;
                }
                
                // å…¶æ¬¡ï¼Œç‚¹å‡»â€œæŸ¥çœ‹ç»“æœâ€æŒ‰é’®
                const btnCheck = document.getElementById('btn-check');
                if (btnCheck && btnCheck.style.display !== 'none') {
                    btnCheck.click();
                    return;
                }
                return; // Enter é”®é€»è¾‘å¤„ç†å®Œæ¯•
            }

            // å¦‚æœç„¦ç‚¹åœ¨ä»»ä½•è¾“å…¥æ¡†æˆ–æ–‡æœ¬åŸŸä¸­ï¼Œåˆ™ä¸è§¦å‘ä»¥ä¸‹çš„å¿«æ·é”®
            if (isInputFocused || isTextareaFocused) {
                return;
            }

            const currentQ = questions[currentIndex];
            if (!currentQ) return;
            const options = currentQ.querySelectorAll('.options label');

            switch (e.key) {
                case '1':
                case '2':
                case '3':
                case '4':
                    e.preventDefault();
                    const optionIndex = parseInt(e.key) - 1;
                    if (options[optionIndex]) {
                        options[optionIndex].querySelector('input').click();
                    }
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    prevQuestion();
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    nextQuestion();
                    break;
                case 'f':
                case 'F':
                    e.preventDefault();
                    const favBtn = currentQ.querySelector('.fav-btn');
                    if (favBtn) {
                        favBtn.click();
                    }
                    break;
            }
        });

        function nextQuestion() {
            if (typeof currentIndex === 'undefined') currentIndex = 0;
            if (currentIndex < totalQuestions - 1) {
                showQuestion(currentIndex + 1);
            }
        }
        function prevQuestion() {
            if (typeof currentIndex === 'undefined') currentIndex = 0;
            if (currentIndex > 0) {
                showQuestion(currentIndex - 1);
            }
        }

        function setupImageGallery(questionElement) {
            const gallery = questionElement.querySelector('.question-image-gallery');
            if (!gallery) return;

            let images = [];
            try {
                const imageData = gallery.dataset.images;
                // Compatibility for both JSON string and plain string
                if (imageData.startsWith('[')) {
                    images = JSON.parse(imageData);
                } else if (imageData) {
                    images = [imageData];
                }
            } catch (e) {
                console.error('Failed to parse image data:', e);
                images = [];
            }

            if (images.length === 0) {
                gallery.style.display = 'none';
                return;
            }

            gallery.style.display = 'block';
            const imageWrapper = gallery.querySelector('.gallery-main-image-wrapper');
            const controls = gallery.querySelector('.gallery-controls');
            const counter = gallery.querySelector('.gallery-counter');
            const prevBtn = gallery.querySelector('.gallery-prev');
            const nextBtn = gallery.querySelector('.gallery-next');

            let currentImageIndex = 0;

            function showImage(index) {
                imageWrapper.innerHTML = `<img src="{{ url_for('main.serve_upload', filename='') }}${images[index]}" alt="é¢˜ç›®å›¾ç‰‡ ${index + 1}" style="max-width: 100%; max-height: 400px; border-radius: 12px; border: 1px solid var(--border-color);">`;
                if (images.length > 1) {
                    counter.textContent = `${index + 1} / ${images.length}`;
                }
            }

            if (images.length > 1) {
                controls.style.display = 'flex';
                prevBtn.onclick = () => {
                    currentImageIndex = (currentImageIndex - 1 + images.length) % images.length;
                    showImage(currentImageIndex);
                };
                nextBtn.onclick = () => {
                    currentImageIndex = (currentImageIndex + 1) % images.length;
                    showImage(currentImageIndex);
                };
            } else {
                controls.style.display = 'none';
            }

            showImage(0);
        }
            function gotoPage(p){
            const url = new URL(window.location.href);
            url.searchParams.set('page', p);
            const szSel = document.getElementById('pageSize');
            if (szSel) url.searchParams.set('size', szSel.value);
            window.location.href = url.toString();
        }
        function changeSize(sz){
            const url = new URL(window.location.href);
            url.searchParams.set('size', sz);
            url.searchParams.set('page', 1);
            window.location.href = url.toString();
        }
    </script>
    <div class="shortcut-hint">âŒ¨ï¸ å¿«æ·é”®ï¼š1~4 é€‰æ‹© A-D ãƒ» â†/â†’ ä¸Š/ä¸‹ä¸€é¢˜ ãƒ» Enter æŸ¥çœ‹ç»“æœ/ä¸‹ä¸€é¢˜ ãƒ» F æ”¶è—/å–æ¶ˆæ”¶è—</div>
</body>
</html>