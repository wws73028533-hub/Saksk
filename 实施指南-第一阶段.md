# 第一阶段实施指南：基础架构优化

> 本指南提供第一阶段优化的详细实施步骤和代码示例

---

## 📋 第一阶段任务清单

- [ ] 1. 创建服务层（Service Layer）
- [ ] 2. 实现统一错误处理机制
- [ ] 3. 引入Pydantic进行数据验证
- [ ] 4. 添加类型提示

---

## 任务1：创建服务层（Service Layer）

### 1.1 目录结构

```
app/services/
├── __init__.py
├── user_service.py
├── question_service.py
├── exam_service.py
├── chat_service.py
└── notification_service.py
```

### 1.2 示例：用户服务层

**文件**：`app/services/user_service.py`

```python
# -*- coding: utf-8 -*-
"""
用户服务层
"""
from typing import Optional, Dict, Any, List
from werkzeug.security import generate_password_hash, check_password_hash
from ..utils.database import get_db
from ..errors import NotFoundError, BadRequestError


class UserService:
    """用户业务逻辑服务"""
    
    @staticmethod
    def create_user(username: str, password: str, is_admin: bool = False) -> Dict[str, Any]:
        """
        创建用户
        
        Args:
            username: 用户名
            password: 密码
            is_admin: 是否为管理员
            
        Returns:
            用户信息字典
            
        Raises:
            BadRequestError: 用户名已存在
        """
        conn = get_db()
        
        # 检查用户名是否已存在
        existing = conn.execute(
            'SELECT id FROM users WHERE username = ?', (username,)
        ).fetchone()
        
        if existing:
            raise BadRequestError('用户名已存在')
        
        # 检查是否是第一个用户（自动成为管理员）
        count = conn.execute('SELECT COUNT(*) FROM users').fetchone()[0]
        if count == 0:
            is_admin = True
        
        password_hash = generate_password_hash(password)
        
        conn.execute(
            'INSERT INTO users (username, password_hash, is_admin) VALUES (?, ?, ?)',
            (username, password_hash, 1 if is_admin else 0)
        )
        conn.commit()
        
        return UserService.get_user_by_username(username)
    
    @staticmethod
    def get_user_by_id(user_id: int) -> Optional[Dict[str, Any]]:
        """
        通过ID获取用户
        
        Args:
            user_id: 用户ID
            
        Returns:
            用户信息字典，不存在返回None
        """
        conn = get_db()
        row = conn.execute(
            'SELECT * FROM users WHERE id = ?', (user_id,)
        ).fetchone()
        return dict(row) if row else None
    
    @staticmethod
    def get_user_by_username(username: str) -> Optional[Dict[str, Any]]:
        """
        通过用户名获取用户
        
        Args:
            username: 用户名
            
        Returns:
            用户信息字典，不存在返回None
        """
        conn = get_db()
        row = conn.execute(
            'SELECT * FROM users WHERE username = ?', (username,)
        ).fetchone()
        return dict(row) if row else None
    
    @staticmethod
    def verify_password(username: str, password: str) -> bool:
        """
        验证密码
        
        Args:
            username: 用户名
            password: 密码
            
        Returns:
            验证是否通过
        """
        user = UserService.get_user_by_username(username)
        if not user:
            return False
        return check_password_hash(user['password_hash'], password)
    
    @staticmethod
    def update_password(user_id: int, new_password: str) -> None:
        """
        更新密码
        
        Args:
            user_id: 用户ID
            new_password: 新密码
        """
        conn = get_db()
        password_hash = generate_password_hash(new_password)
        conn.execute(
            'UPDATE users SET password_hash = ? WHERE id = ?',
            (password_hash, user_id)
        )
        conn.commit()
    
    @staticmethod
    def get_user_list(
        search: str = '',
        page: int = 1,
        size: int = 10,
        sort: str = 'created_at',
        order: str = 'desc'
    ) -> Dict[str, Any]:
        """
        获取用户列表（分页）
        
        Args:
            search: 搜索关键词
            page: 页码
            size: 每页数量
            sort: 排序字段
            order: 排序方向
            
        Returns:
            包含data和total的字典
        """
        conn = get_db()
        offset = (page - 1) * size
        
        where = 'WHERE 1=1'
        params: List[Any] = []
        
        if search:
            where += ' AND username LIKE ?'
            params.append(f'%{search}%')
        
        # 验证排序字段
        allowed_sorts = {'created_at', 'username', 'id'}
        if sort not in allowed_sorts:
            sort = 'created_at'
        if order not in ('asc', 'desc'):
            order = 'desc'
        
        # 获取总数
        total = conn.execute(
            f'SELECT COUNT(*) FROM users {where}', params
        ).fetchone()[0]
        
        # 获取数据
        rows = conn.execute(
            f'''SELECT id, username, is_admin, is_locked, created_at 
                FROM users {where} 
                ORDER BY {sort} {order} 
                LIMIT ? OFFSET ?''',
            params + [size, offset]
        ).fetchall()
        
        return {
            'data': [dict(row) for row in rows],
            'total': total
        }
```

### 1.3 更新路由使用服务层

**文件**：`app/routes/auth.py`（示例）

```python
from flask import Blueprint, request, jsonify, session
from app.services.user_service import UserService
from app.errors import BadRequestError, NotFoundError

auth_bp = Blueprint('auth', __name__)

@auth_bp.route('/api/register', methods=['POST'])
def api_register():
    """注册API"""
    data = request.json or {}
    username = (data.get('username') or '').strip()
    password = data.get('password') or ''
    
    try:
        user = UserService.create_user(username, password)
        return jsonify({
            'status': 'success',
            'message': '注册成功',
            'user_id': user['id']
        }), 201
    except BadRequestError as e:
        return jsonify({
            'status': 'error',
            'message': str(e)
        }), 400
```

---

## 任务2：实现统一错误处理机制

### 2.1 创建错误处理模块

**文件**：`app/errors.py`

```python
# -*- coding: utf-8 -*-
"""
统一错误处理模块
"""
from flask import Flask, jsonify
from werkzeug.exceptions import HTTPException
from typing import Optional, Dict, Any


class APIError(HTTPException):
    """API基础异常类"""
    code = 500
    description = 'An unexpected error occurred.'
    
    def __init__(
        self,
        message: Optional[str] = None,
        code: Optional[int] = None,
        payload: Optional[Dict[str, Any]] = None
    ):
        if message:
            self.description = message
        if code:
            self.code = code
        self.payload = payload
        super().__init__(description=self.description)
    
    def get_response(self, environment=None):
        """生成错误响应"""
        response = jsonify({
            'status': 'error',
            'message': self.description,
            'code': self.code,
            'payload': self.payload
        })
        response.status_code = self.code
        return response


class BadRequestError(APIError):
    """400 错误请求"""
    code = 400
    description = 'Invalid request payload.'


class UnauthorizedError(APIError):
    """401 未授权"""
    code = 401
    description = 'Authentication required.'


class ForbiddenError(APIError):
    """403 禁止访问"""
    code = 403
    description = 'Access forbidden.'


class NotFoundError(APIError):
    """404 资源未找到"""
    code = 404
    description = 'Resource not found.'


class ConflictError(APIError):
    """409 冲突"""
    code = 409
    description = 'Resource conflict.'


class ValidationError(APIError):
    """422 验证错误"""
    code = 422
    description = 'Validation failed.'
    
    def __init__(self, message: str, errors: Optional[Dict[str, Any]] = None):
        super().__init__(message=message, code=422)
        self.payload = {'errors': errors} if errors else None


def register_error_handlers(app: Flask) -> None:
    """注册错误处理器"""
    
    @app.errorhandler(APIError)
    def handle_api_error(error: APIError):
        """处理API错误"""
        return error.get_response()
    
    @app.errorhandler(HTTPException)
    def handle_http_exception(e: HTTPException):
        """处理HTTP异常"""
        return APIError(
            message=e.description,
            code=e.code
        ).get_response()
    
    @app.errorhandler(Exception)
    def handle_generic_exception(e: Exception):
        """处理未捕获的异常"""
        app.logger.error(f"Unhandled exception: {e}", exc_info=True)
        return APIError(
            message="An unexpected server error occurred.",
            code=500
        ).get_response()
```

### 2.2 在应用工厂中注册

**文件**：`app/__init__.py`

```python
def create_app(config_name=None):
    # ... 现有代码 ...
    
    # 注册错误处理器
    from .errors import register_error_handlers
    register_error_handlers(app)
    
    # ... 其他代码 ...
```

---

## 任务3：引入Pydantic进行数据验证

### 3.1 安装Pydantic

```bash
pip install pydantic pydantic[email]
```

### 3.2 创建Schema模块

**文件**：`app/schemas.py`

```python
# -*- coding: utf-8 -*-
"""
Pydantic数据验证模型
"""
from pydantic import BaseModel, Field, EmailStr, validator
from typing import Optional, List, Dict, Any
from datetime import datetime


# ========== 用户相关 ==========

class UserCreateSchema(BaseModel):
    """用户创建Schema"""
    username: str = Field(..., min_length=3, max_length=20, description="用户名")
    password: str = Field(..., min_length=6, max_length=100, description="密码")
    email: Optional[EmailStr] = Field(None, description="邮箱")
    
    @validator('username')
    def validate_username(cls, v):
        """验证用户名格式"""
        if not v.strip():
            raise ValueError('用户名不能为空')
        return v.strip()


class UserLoginSchema(BaseModel):
    """用户登录Schema"""
    username: str = Field(..., description="用户名")
    password: str = Field(..., description="密码")
    remember: bool = Field(False, description="记住登录")
    redirect: Optional[str] = Field(None, description="登录后跳转地址")


class UserUpdateSchema(BaseModel):
    """用户更新Schema"""
    avatar: Optional[str] = None
    contact: Optional[str] = None
    college: Optional[str] = None


class UserResponseSchema(BaseModel):
    """用户响应Schema"""
    id: int
    username: str
    email: Optional[str] = None
    avatar: Optional[str] = None
    contact: Optional[str] = None
    college: Optional[str] = None
    is_admin: bool
    is_locked: bool
    created_at: str
    
    class Config:
        from_attributes = True


# ========== 题目相关 ==========

class QuestionResponseSchema(BaseModel):
    """题目响应Schema"""
    id: int
    content: str
    q_type: str
    subject_id: int
    subject: Optional[str] = None
    options: Optional[List[str]] = None
    answer: str
    explanation: Optional[str] = None
    difficulty: Optional[int] = None
    is_fav: Optional[int] = 0
    is_mistake: Optional[int] = 0
    
    class Config:
        from_attributes = True


class QuestionCreateSchema(BaseModel):
    """题目创建Schema"""
    content: str = Field(..., min_length=1, description="题目内容")
    q_type: str = Field(..., description="题型")
    subject_id: int = Field(..., description="科目ID")
    options: Optional[List[str]] = Field(None, description="选项（选择题）")
    answer: str = Field(..., min_length=1, description="答案")
    explanation: Optional[str] = None
    difficulty: Optional[int] = Field(1, ge=1, le=5, description="难度1-5")


# ========== 考试相关 ==========

class ExamCreateSchema(BaseModel):
    """考试创建Schema"""
    subject: str = Field(..., description="科目")
    duration: int = Field(..., gt=0, description="时长（分钟）")
    types: Dict[str, int] = Field(..., description="题型配置")
    scores: Dict[str, int] = Field(..., description="分值配置")


class ExamSubmitSchema(BaseModel):
    """考试提交Schema"""
    exam_id: int = Field(..., description="考试ID")
    answers: List[Dict[str, Any]] = Field(..., description="答案列表")
    
    @validator('answers')
    def validate_answers(cls, v):
        """验证答案格式"""
        if not v:
            raise ValueError('答案不能为空')
        return v


# ========== 聊天相关 ==========

class ChatMessageSendSchema(BaseModel):
    """聊天消息发送Schema"""
    conversation_id: int = Field(..., description="会话ID")
    content: str = Field(..., min_length=1, max_length=5000, description="消息内容")
    
    @validator('content')
    def validate_content(cls, v):
        if not v.strip():
            raise ValueError('消息内容不能为空')
        return v.strip()
```

### 3.3 在路由中使用Schema

**文件**：`app/routes/auth.py`（示例）

```python
from flask import Blueprint, request, jsonify, session
from pydantic import ValidationError
from app.schemas import UserCreateSchema, UserLoginSchema
from app.services.user_service import UserService
from app.errors import BadRequestError

auth_bp = Blueprint('auth', __name__)

@auth_bp.route('/api/register', methods=['POST'])
def api_register():
    """注册API"""
    try:
        # 使用Pydantic验证请求数据
        user_data = UserCreateSchema.parse_obj(request.json or {})
        
        # 调用服务层
        user = UserService.create_user(
            username=user_data.username,
            password=user_data.password
        )
        
        return jsonify({
            'status': 'success',
            'message': '注册成功',
            'user_id': user['id']
        }), 201
        
    except ValidationError as e:
        # Pydantic验证错误
        errors = {err['loc'][0]: err['msg'] for err in e.errors()}
        return jsonify({
            'status': 'error',
            'message': '数据验证失败',
            'errors': errors
        }), 400
        
    except BadRequestError as e:
        return jsonify({
            'status': 'error',
            'message': str(e)
        }), 400
```

---

## 任务4：添加类型提示

### 4.1 为服务层添加类型提示

已在任务1的示例中包含类型提示。

### 4.2 为路由添加类型提示

**示例**：

```python
from flask import Blueprint, request, Response
from typing import Dict, Any, Tuple

@auth_bp.route('/api/login', methods=['POST'])
def api_login() -> Tuple[Response, int]:
    """登录API"""
    # ... 实现 ...
    return jsonify({...}), 200
```

### 4.3 配置mypy进行类型检查

**文件**：`pyproject.toml` 或 `.mypy.ini`

```ini
[mypy]
python_version = 3.11
warn_return_any = True
warn_unused_configs = True
disallow_untyped_defs = False  # 逐步启用
ignore_missing_imports = True

[mypy-flask.*]
ignore_missing_imports = True
```

---

## 📝 实施步骤

### 步骤1：创建基础结构
1. 创建 `app/services/` 目录
2. 创建 `app/errors.py`
3. 创建 `app/schemas.py`

### 步骤2：选择一个模块作为试点
建议从**用户模块**开始：
1. 创建 `UserService`
2. 创建用户相关的Schema
3. 更新 `auth.py` 路由使用服务层和Schema
4. 测试验证

### 步骤3：逐步迁移其他模块
按优先级迁移：
1. 题目模块（QuestionService）
2. 考试模块（ExamService）
3. 聊天模块（ChatService）
4. 通知模块（NotificationService）

### 步骤4：完善错误处理
1. 在应用工厂注册错误处理器
2. 更新所有路由使用自定义异常
3. 统一API响应格式

---

## ✅ 验收标准

- [ ] 所有业务逻辑已从路由抽离到服务层
- [ ] 所有API使用Pydantic进行数据验证
- [ ] 统一错误处理机制已实现并应用
- [ ] 核心函数已添加类型提示
- [ ] 代码可以正常运行，功能不受影响

---

## 🚨 注意事项

1. **渐进式重构**：不要一次性修改所有代码，按模块逐步推进
2. **保持兼容**：确保API接口保持向后兼容
3. **充分测试**：每次修改后都要进行功能测试
4. **代码审查**：重要修改要进行代码审查

---

**最后更新**：2025-01-23

