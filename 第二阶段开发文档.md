# 编程题模块第二阶段开发文档（功能增强）

## 📋 文档信息

- **版本**: v1.0
- **创建日期**: 2025-12-29
- **阶段**: 第二阶段（功能增强）
- **目标**: 完善功能，提升用户体验
- **前置条件**: 第一阶段（MVP）已完成 ✅

---

## 🎯 开发目标

在完成第一阶段基础功能的基础上，进一步完善功能，提升用户体验，包括：
- 实现提交历史页（独立页面）
- 实现统计页面（可视化数据）
- 实现收藏功能
- 优化代码自动保存
- 优化判题性能
- 添加更多编程语言支持（Java、C++）

---

## 📦 任务清单

### ⬜ 待完成任务

1. ⬜ **实现提交历史页** - 独立页面展示用户提交记录
2. ⬜ **实现统计页面** - 可视化用户练习数据
3. ⬜ **实现收藏功能** - 题目收藏与收藏列表
4. ⬜ **优化代码自动保存** - 实时保存与恢复
5. ⬜ **优化判题性能** - 并发处理与缓存优化
6. ⬜ **添加更多编程语言支持** - Java、C++ 支持

---

## 📝 详细开发任务

### 任务 1: 实现提交历史页

**文件**: `app/modules/coding/templates/coding/submissions.html`

**功能要求**:
- 显示用户的所有提交记录
- 支持按题目、状态、时间筛选
- 显示提交详情（代码、结果、执行时间）
- 支持查看提交详情、重新提交、删除记录

**页面布局**:
- 顶部：筛选器（题目选择、状态筛选、时间范围）
- 中间：提交记录表格/卡片列表
- 底部：分页器

**数据字段**:
- 提交ID
- 题目标题（可点击跳转）
- 提交时间
- 执行状态（通过/失败/错误/超时）
- 通过测试用例数/总测试用例数
- 执行时间
- 代码语言
- 操作按钮（查看详情、重新提交、删除）

**API端点**:
- `GET /coding/api/submissions` - 已实现，需要优化
- `GET /coding/api/submissions/<submission_id>` - 已实现
- `DELETE /coding/api/submissions/<submission_id>` - 需要新增

**实现要点**:
```python
# 新增删除提交记录API
@coding_api_bp.route('/submissions/<int:submission_id>', methods=['DELETE'])
@login_required
def api_delete_submission(submission_id: int):
    """删除提交记录"""
    # 1. 验证提交记录属于当前用户
    # 2. 删除记录
    # 3. 返回成功响应
    pass
```

**UI设计**:
- iOS 18风格，毛玻璃效果卡片
- 状态标签（通过/失败）使用不同颜色
- 响应式表格/卡片布局
- 操作按钮使用下拉菜单

---

### 任务 2: 实现统计页面

**文件**: `app/modules/coding/templates/coding/statistics.html`

**功能要求**:
- 显示用户编程题练习统计
- 题目完成情况可视化
- 提交成功率图表
- 各难度题目分布
- 时间趋势分析

**统计指标**:
- 总提交次数
- 通过题目数
- 总题目数
- 提交成功率
- 各难度题目完成情况（easy/medium/hard）
- 最近7天/30天提交趋势
- 最佳执行时间统计

**可视化组件**:
- 使用 Chart.js 或 ECharts 绘制图表
- 饼图：各难度题目分布
- 柱状图：每日提交次数
- 折线图：通过率趋势
- 进度条：各难度完成进度

**API端点**:
- `GET /coding/api/statistics` - 已实现，需要扩展数据

**实现要点**:
```python
# 扩展统计API，添加时间趋势数据
@coding_api_bp.route('/statistics', methods=['GET'])
@login_required
def api_get_statistics():
    """获取用户统计（扩展版）"""
    # 返回数据包括：
    # - 基础统计（已实现）
    # - 最近7天/30天提交趋势
    # - 每日通过率趋势
    # - 各难度详细统计
    pass
```

**UI设计**:
- 卡片式布局，每个统计指标一个卡片
- 图表使用毛玻璃背景
- 响应式设计，适配移动端

---

### 任务 3: 实现收藏功能

**功能要求**:
- 用户可收藏/取消收藏题目
- 显示收藏列表
- 在题目列表页显示收藏状态
- 支持按收藏状态筛选

**数据库设计**:
- 新增表：`coding_favorites`
  - `id` (INTEGER PRIMARY KEY)
  - `user_id` (INTEGER)
  - `question_id` (INTEGER)
  - `created_at` (DATETIME)
  - UNIQUE(user_id, question_id)

**API端点**:
```python
# POST /coding/api/questions/<question_id>/favorite
# 收藏题目
@coding_api_bp.route('/questions/<int:question_id>/favorite', methods=['POST'])
@login_required
def api_favorite_question(question_id: int):
    """收藏题目"""
    pass

# DELETE /coding/api/questions/<question_id>/favorite
# 取消收藏
@coding_api_bp.route('/questions/<int:question_id>/favorite', methods=['DELETE'])
@login_required
def api_unfavorite_question(question_id: int):
    """取消收藏"""
    pass

# GET /coding/api/questions/favorites
# 获取收藏列表
@coding_api_bp.route('/questions/favorites', methods=['GET'])
@login_required
def api_get_favorites():
    """获取收藏列表"""
    pass
```

**服务层**:
```python
# app/modules/coding/services/favorite_service.py
class FavoriteService:
    @staticmethod
    def add_favorite(user_id: int, question_id: int) -> bool:
        """添加收藏"""
        pass
    
    @staticmethod
    def remove_favorite(user_id: int, question_id: int) -> bool:
        """取消收藏"""
        pass
    
    @staticmethod
    def is_favorite(user_id: int, question_id: int) -> bool:
        """检查是否收藏"""
        pass
    
    @staticmethod
    def get_favorites(user_id: int, page: int = 1, per_page: int = 20) -> Dict:
        """获取收藏列表"""
        pass
```

**前端实现**:
- 在题目列表页和详情页添加收藏按钮（心形图标）
- 点击切换收藏状态
- 收藏列表页面显示所有收藏的题目

---

### 任务 4: 优化代码自动保存

**功能要求**:
- 实时保存代码（防抖处理，避免频繁保存）
- 页面刷新后自动恢复代码
- 支持多题目代码同时保存
- 显示保存状态提示

**实现要点**:
```javascript
// 优化代码自动保存
let saveTimer = null;

editor.onDidChangeModelContent(() => {
    const code = editor.getValue();
    
    // 防抖处理：500ms 后保存
    clearTimeout(saveTimer);
    saveTimer = setTimeout(() => {
        localStorage.setItem(`coding_${questionId}`, code);
        localStorage.setItem(`coding_${questionId}_timestamp`, Date.now());
        showSaveStatus('已保存');
    }, 500);
    
    showSaveStatus('保存中...');
});

// 页面加载时恢复代码
window.addEventListener('load', () => {
    const savedCode = localStorage.getItem(`coding_${questionId}`);
    const timestamp = localStorage.getItem(`coding_${questionId}_timestamp`);
    
    if (savedCode) {
        const savedTime = new Date(parseInt(timestamp));
        const now = new Date();
        const diffHours = (now - savedTime) / (1000 * 60 * 60);
        
        if (diffHours < 24) { // 24小时内保存的代码才恢复
            if (confirm(`检测到未保存的代码（${savedTime.toLocaleString()}），是否恢复？`)) {
                editor.setValue(savedCode);
            }
        }
    }
});
```

**优化点**:
- 使用防抖（debounce）减少保存频率
- 添加时间戳，避免恢复过期代码
- 显示保存状态（保存中/已保存）
- 支持手动保存快捷键（Ctrl+S）

---

### 任务 5: 优化判题性能

**功能要求**:
- 并发处理多个测试用例
- 缓存题目测试用例数据
- 优化代码执行流程
- 减少数据库查询

**实现要点**:
```python
# 优化判题服务，支持并发执行
import concurrent.futures
from typing import List, Dict

class JudgeService:
    def judge_concurrent(
        self,
        question_id: int,
        code: str,
        language: str = 'python',
        max_workers: int = 4
    ) -> Dict[str, Any]:
        """并发判题（优化性能）"""
        # 1. 获取测试用例（使用缓存）
        test_cases = self._get_test_cases_cached(question_id)
        
        # 2. 并发执行测试用例
        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            futures = [
                executor.submit(self._execute_test_case, code, language, case)
                for case in test_cases
            ]
            
            results = []
            for future in concurrent.futures.as_completed(futures):
                results.append(future.result())
        
        # 3. 汇总结果
        return self._aggregate_results(results)
    
    def _get_test_cases_cached(self, question_id: int) -> List[Dict]:
        """获取测试用例（带缓存）"""
        cache_key = f"test_cases_{question_id}"
        # 使用 Redis 或内存缓存
        # 如果缓存未命中，从数据库加载并缓存
        pass
```

**优化策略**:
- 使用线程池并发执行测试用例
- 使用缓存存储题目测试用例（避免重复查询数据库）
- 优化代码执行器，减少进程创建开销
- 批量处理提交记录写入

---

### 任务 6: 添加更多编程语言支持

**功能要求**:
- 支持 Java 代码执行
- 支持 C++ 代码执行
- 代码验证器支持多语言
- 前端编辑器支持多语言语法高亮

**实现要点**:

#### 6.1 Java 执行器

```python
# app/modules/coding/services/code_executor.py

class JavaExecutor(CodeExecutor):
    """Java 代码执行器"""
    
    def execute(
        self,
        code: str,
        language: str = 'java',
        input_data: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        执行 Java 代码
        
        流程：
        1. 验证代码（检查类名、主方法）
        2. 创建临时 .java 文件
        3. 编译：javac Main.java
        4. 运行：java Main
        5. 捕获输出和错误
        """
        # 1. 代码验证
        if not self._validate_java_code(code):
            return {
                'status': 'error',
                'output': '',
                'error': 'Java代码格式错误',
                'execution_time': 0
            }
        
        # 2. 创建临时文件
        with tempfile.TemporaryDirectory() as tmpdir:
            java_file = os.path.join(tmpdir, 'Main.java')
            with open(java_file, 'w', encoding='utf-8') as f:
                f.write(code)
            
            # 3. 编译
            compile_result = subprocess.run(
                ['javac', java_file],
                capture_output=True,
                text=True,
                timeout=10,
                cwd=tmpdir
            )
            
            if compile_result.returncode != 0:
                return {
                    'status': 'error',
                    'output': '',
                    'error': compile_result.stderr,
                    'execution_time': 0
                }
            
            # 4. 运行
            start_time = time.time()
            try:
                process = subprocess.Popen(
                    ['java', '-cp', tmpdir, 'Main'],
                    stdin=subprocess.PIPE,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    encoding='utf-8',
                    errors='replace'
                )
                
                input_str = input_data if input_data else ''
                stdout, stderr = process.communicate(
                    input=input_str,
                    timeout=self.time_limit
                )
                execution_time = time.time() - start_time
                
                if process.returncode == 0:
                    return {
                        'status': 'success',
                        'output': self._truncate_output(stdout),
                        'error': None,
                        'execution_time': round(execution_time, 3)
                    }
                else:
                    return {
                        'status': 'error',
                        'output': self._truncate_output(stdout),
                        'error': self._truncate_output(stderr),
                        'execution_time': round(execution_time, 3)
                    }
            except subprocess.TimeoutExpired:
                process.kill()
                return {
                    'status': 'timeout',
                    'output': '',
                    'error': f'代码执行超时（超过 {self.time_limit} 秒）',
                    'execution_time': self.time_limit
                }
    
    def _validate_java_code(self, code: str) -> bool:
        """验证Java代码格式"""
        # 检查是否包含 public class Main
        # 检查是否包含 public static void main(String[] args)
        # 禁止危险导入
        pass
```

#### 6.2 C++ 执行器

```python
class CppExecutor(CodeExecutor):
    """C++ 代码执行器"""
    
    def execute(
        self,
        code: str,
        language: str = 'cpp',
        input_data: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        执行 C++ 代码
        
        流程：
        1. 验证代码
        2. 创建临时 .cpp 文件
        3. 编译：g++ -o main main.cpp
        4. 运行：./main
        5. 捕获输出和错误
        """
        # 类似 Java 执行器的实现
        pass
```

#### 6.3 代码执行器工厂

```python
class CodeExecutorFactory:
    """代码执行器工厂"""
    
    @staticmethod
    def create_executor(language: str, time_limit: int = 5) -> CodeExecutor:
        """根据语言创建执行器"""
        executors = {
            'python': PythonExecutor,
            'java': JavaExecutor,
            'cpp': CppExecutor,
            'c++': CppExecutor
        }
        
        executor_class = executors.get(language.lower())
        if not executor_class:
            raise ValueError(f'不支持的编程语言: {language}')
        
        return executor_class(time_limit=time_limit)
```

#### 6.4 前端多语言支持

```javascript
// 在 detail.html 中
const languageMap = {
    'python': 'python',
    'java': 'java',
    'cpp': 'cpp',
    'c++': 'cpp'
};

// 根据题目语言设置编辑器
if (questionData.programming_language) {
    const lang = languageMap[questionData.programming_language] || 'python';
    monaco.editor.setModelLanguage(editor.getModel(), lang);
}
```

---

## 🔧 开发规范

### 代码组织

1. **保持模块独立性**: 新功能仍在 `app/modules/coding/` 目录下
2. **服务层扩展**: 新增服务类放在 `services/` 目录
3. **数据库迁移**: 新增表需要在 `app/core/utils/database.py` 中处理
4. **API版本控制**: 保持 RESTful 风格

### 数据库操作

1. **新增表**: `coding_favorites` 表需要创建
2. **索引优化**: 为常用查询字段添加索引
3. **数据迁移**: 确保现有数据兼容

### UI设计

1. **保持iOS 18风格**: 所有新页面遵循设计规范
2. **响应式设计**: 适配移动端和桌面端
3. **性能优化**: 图表使用懒加载，大数据分页

---

## 📋 开发顺序建议

### 推荐开发顺序

1. **任务1: 提交历史页** - 基础功能，相对独立
2. **任务3: 收藏功能** - 功能简单，用户需求高
3. **任务4: 优化代码自动保存** - 提升用户体验
4. **任务2: 统计页面** - 需要数据积累，可稍后实现
5. **任务5: 优化判题性能** - 性能优化，可并行开发
6. **任务6: 多语言支持** - 功能扩展，优先级较低

---

## ✅ 检查清单

每个任务完成后，检查：

- [ ] 代码遵循项目规范（类型提示、错误处理、参数化查询）
- [ ] API返回统一的JSON格式
- [ ] UI遵循iOS 18设计风格
- [ ] 添加必要的权限检查
- [ ] 代码有适当的注释
- [ ] 数据库操作使用参数化查询
- [ ] 错误处理完善（try-except、日志记录）
- [ ] 前端使用async/await处理异步操作
- [ ] 性能优化（缓存、并发、懒加载）
- [ ] 响应式设计，适配移动端

---

## 📚 参考资源

- **Chart.js**: https://www.chartjs.org/ - 图表库
- **ECharts**: https://echarts.apache.org/ - 数据可视化
- **Monaco Editor多语言**: https://microsoft.github.io/monaco-editor/
- **Java编译执行**: Java Development Kit (JDK)
- **C++编译执行**: GCC/G++ 编译器
- **项目规范**: `.cursor/rules/admin-guide.mdc`, `.cursor/rules/flask-restful.mdc`

---

## 🚀 开始开发

1. 按照推荐开发顺序，从任务1开始
2. 每个任务完成后，更新任务状态（✅）
3. 遇到问题及时记录和解决
4. 定期检查代码规范和性能

---

**文档版本**: v1.0  
**创建日期**: 2025-12-29  
**最后更新**: 2025-12-29  
**维护者**: 开发团队  
**状态**: 待开发 ⬜

